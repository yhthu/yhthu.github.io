<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>道阻且长【yhthu.com】</title>
  <subtitle>分享交流Android、CV、ML、NN等方面的技术和设计思想</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yhthu.com/"/>
  <updated>2016-04-25T09:15:03.864Z</updated>
  <id>http://yhthu.com/</id>
  
  <author>
    <name>yhthu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发笔记——视频录制播放常见问题</title>
    <link href="http://yhthu.com/2016/04/25/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%E6%92%AD%E6%94%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yhthu.com/2016/04/25/Android开发笔记——视频录制播放常见问题/</id>
    <published>2016-04-25T09:14:47.651Z</published>
    <updated>2016-04-25T09:15:03.864Z</updated>
    
    <content type="html">&lt;p&gt;本文分享自己在视频录制播放过程中遇到的一些问题，主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视频录制流程&lt;/li&gt;
&lt;li&gt;视频预览及SurfaceHolder&lt;/li&gt;
&lt;li&gt;视频清晰度及文件大小&lt;/li&gt;
&lt;li&gt;视频文件旋转&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、视频录制流程&quot;&gt;&lt;a href=&quot;#一、视频录制流程&quot; class=&quot;headerlink&quot; title=&quot;一、视频录制流程&quot;&gt;&lt;/a&gt;一、视频录制流程&lt;/h2&gt;&lt;p&gt;以微信为例，其录制触发为按下（住）录制按钮，结束录制的触发条件为松开录制按钮或录制时间结束，其流程大概可以用下图来描述。&lt;br&gt;&lt;img src=&quot;/img/20151230-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1、开始录制&quot;&gt;&lt;a href=&quot;#1-1、开始录制&quot; class=&quot;headerlink&quot; title=&quot;1.1、开始录制&quot;&gt;&lt;/a&gt;1.1、开始录制&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/img/20151230-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;初始化过程主要包括View，Data以及Listener三部分。在初始化View时，添加摄像头预览，添加倒计时文本组件，设置初始状态UI组件的可见；初始化Data时，从Intent中获取初始数据；初始化Listener时，分别对录制触发按钮，保存/取消视频录制按钮以及视频预览界面添加监听。&lt;br&gt;当系统初始化成功后，等待用户按下录制按钮，因此在录制按钮的监听中，需要完成以下功能：录制，计时，更新界面组件。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(isRecording) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    releaseMediaRecorder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mCamera.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    isRecording = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(startRecordVideo()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    startTimeVideoRecord();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    isRecording = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;首先判断当前录制状态，如果正在录制，则先停止录制，释放MediaRecorder资源，锁定摄像头，置位录制状态；然后开始视频录制startRecordVideo，其boolean型返回值表征是否启动成功，启动成功后，开始视频录制计时，并且置位录制状态。startRecordVideo涉及MediaRecorder的配置，准备以及启动。&lt;br&gt;&lt;img src=&quot;/img/20151230-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;翻译成代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private boolean startRecordVideo() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configureMediaRecorder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!prepareConfiguredMediaRecorder()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2、结束录制&quot;&gt;&lt;a href=&quot;#1-2、结束录制&quot; class=&quot;headerlink&quot; title=&quot;1.2、结束录制&quot;&gt;&lt;/a&gt;1.2、结束录制&lt;/h3&gt;&lt;p&gt;根据上述流程图可知，结束录制的触发条件为松开录制按钮或计时时间到。在结束录制方法中，需要释放MediaRecorder，开始循环播放已录制视频，设置界面更新等。&lt;br&gt;&lt;img src=&quot;/img/20151230-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; 翻译成代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void stopRecordVideo() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    releaseMediaRecorder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 录制视频文件处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(currentRecordProgress &amp;lt; MIN_RECORD_TIME) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Toast.makeText(VideoInputActivity.this, &amp;quot;录制时间太短&amp;quot;, Toast.LENGTH_SHORT).show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        startVideoPlay();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isPlaying = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setUiDisplayAfterVideoRecordFinish();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    currentRecordProgress = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    updateProgressBar(currentRecordProgress);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    releaseTimer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 状态设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    isRecording = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、视频预览及SurfaceHolder&quot;&gt;&lt;a href=&quot;#二、视频预览及SurfaceHolder&quot; class=&quot;headerlink&quot; title=&quot;二、视频预览及SurfaceHolder&quot;&gt;&lt;/a&gt;二、视频预览及SurfaceHolder&lt;/h2&gt;&lt;p&gt;视频预览采用SurfaceView，相比于普通的View，SurfaceView在一个新起的单独线程中绘制画面，该实现的优点是更新画面不会阻塞UI主线程，缺点是会带来事件同步的问题。当然，这涉及到UI事件的传递以及线程同步，这里不做详细说明，有兴趣的可以参考链接：&lt;a href=&quot;http://wugengxin.cn/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wugengxin.cn/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf。&lt;/a&gt;&lt;br&gt;在实现中，通过继承SurfaceView组件来实现自定义预览控件。首先，SurfaceView的getHolder()方法会返回SurfaceHolder，需要为SurfaceHolder添加SurfaceHolder.Callback回调；其次，重写surfaceCreated、surfaceChanged和surfaceDestroyed实现。&lt;/p&gt;
&lt;h3 id=&quot;2-1、构造器&quot;&gt;&lt;a href=&quot;#2-1、构造器&quot; class=&quot;headerlink&quot; title=&quot;2.1、构造器&quot;&gt;&lt;/a&gt;2.1、构造器&lt;/h3&gt;&lt;p&gt;构造器包含了初始化域以及添加上述回调的过程。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public CameraPreview(Context context, Camera camera) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super(context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mCamera = camera;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mSupportedPreviewSizes = mCamera.getParameters().getSupportedPreviewSizes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mHolder = getHolder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mHolder.addCallback(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里需要说明mSupportedPreviewSizes，由于摄像头支持的预览尺寸由Camera本身的参数决定，因此需要首先获取其所支持的预览尺寸。&lt;/p&gt;
&lt;h3 id=&quot;2-2、预览尺寸的设置&quot;&gt;&lt;a href=&quot;#2-2、预览尺寸的设置&quot; class=&quot;headerlink&quot; title=&quot;2.2、预览尺寸的设置&quot;&gt;&lt;/a&gt;2.2、预览尺寸的设置&lt;/h3&gt;&lt;p&gt;从Google官方的Camera示例程序中可以看出，选择预览尺寸的标准是（1）摄像头支持的预览尺寸的宽高比与SurfaceView的宽高比的绝对差值小于0.1；（2）在（1）获得的尺寸中，选取与SurfaceView的高的差值最小的。通过代码对这两个标准进行了实现，这里贴一下官方的代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public Camera.Size getOptimalPreviewSize(List&amp;lt;Camera.Size&amp;gt; sizes, int w, int h) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    final double ASPECT_TOLERANCE = 0.1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double targetRatio = (double) w / h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (sizes == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Camera.Size optimalSize = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double minDiff = Double.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int targetHeight = h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (Camera.Size size : sizes) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        double ratio = (double) size.width / size.height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (Math.abs(ratio - targetRatio) &amp;gt; ASPECT_TOLERANCE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            continue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (Math.abs(size.height - targetHeight) &amp;lt; minDiff) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            optimalSize = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minDiff = Math.abs(size.height - targetHeight);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (optimalSize == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        minDiff = Double.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (Camera.Size size : sizes) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (Math.abs(size.height - targetHeight) &amp;lt; minDiff) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                optimalSize = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                minDiff = Math.abs(size.height - targetHeight);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return optimalSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在加载预览画面时，需要考虑Camera支持的尺寸（getSupportedPreviewSizes）和加载预览画面的SurfaceView的尺寸（layout_width/layout_height），在预览阶段，两者之间的关系直接影响清晰度及图像拉伸。对于Camera的尺寸，由于设备的硬件差异，不同设备支持的尺寸存在差异，但在默认情况（orientation=landscape）下，其width&amp;gt;height。以HTC609d为例，Camera支持的分辨率为1280&lt;em&gt;720（16：9）……640&lt;/em&gt;480（4：3）……480&lt;em&gt;320（3：2）等十多种，而其屏幕的分辨率为960&lt;/em&gt;540（16：9）。因此，很容易得到以下结论：（1）当Camera预览尺寸小于SurfaceView尺寸较多时，预览画面就不清晰；（2）Camera预览尺寸宽高比与SurfaceView宽高比相差较大时，预览画面就会拉伸。&lt;br&gt;上述代码在手机设置为横屏时并没有问题，在设置为竖屏时，为获得最优的预览尺寸，需要在调用此方法前比较SurfaceView的宽高。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (mSupportedPreviewSizes != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mPreviewSize = getOptimalPreviewSize(mSupportedPreviewSizes, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        Math.max(width, height), Math.min(width, height));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;获得与当前SurfaceView匹配的预览尺寸后，即可通过Camera.Parameters进行设置。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Camera.Parameters mParams = mCamera.getParameters();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mParams.setPreviewSize(mPreviewSize.width, mPreviewSize.height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mCamera.setDisplayOrientation(90);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; focusModes = mParams.getSupportedFocusModes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(focusModes.contains(&amp;quot;continuous-video&amp;quot;))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mParams.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mCamera.setParameters(mParams);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、视频清晰度及文件大小&quot;&gt;&lt;a href=&quot;#三、视频清晰度及文件大小&quot; class=&quot;headerlink&quot; title=&quot;三、视频清晰度及文件大小&quot;&gt;&lt;/a&gt;三、视频清晰度及文件大小&lt;/h2&gt;&lt;p&gt;在第一节中讲到startRecordVideo，包括配置MediaRecorder，准备MediaRecorder以及启动，其中配置MediaRecorder是视频录制的重点，需要了解每项配置参数的作用，根据业务场景灵活配置。这里参考Google官方的示例给出一个可行的配置方案，然后再对其进行解释。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void configureMediaRecorder() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // BEGIN_INCLUDE (configure_media_recorder)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder = new MediaRecorder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Step 1: Unlock and set camera to MediaRecorder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mCamera.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setCamera(mCamera);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setOrientationHint(90);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Step 2: Set sources&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.VOICE_RECOGNITION);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Step 3: Set a Camera Parameters&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* Fixed video Size: 640 * 480*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setVideoSize(640, 480);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* Encoding bit rate: 1 * 1024 * 1024*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setVideoEncodingBitRate(1 * 1024 * 1024);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Step 4: Set output file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setMaxFileSize(maxFileSizeInBytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setOutputFile(videoFilePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // END_INCLUDE (configure_media_recorder)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Set MediaRecorder ErrorListener&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMediaRecorder.setOnErrorListener(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1：&lt;/strong&gt;&lt;br&gt;setCamera参数能够使得在预览和录制中快速切换，避免Camera对象的重新加载。在某些Android手机自带的照相机程序中，切换预览与录制中的短暂卡顿，读者可自行体会。&lt;br&gt;mMediaRecorder.setOrientationHint(90)在录制方向为竖直（portrait）时使用，它能使视频文件的沿顺时针方向旋转90度，如果不设置此项，播放视频时，画面会发生90度的旋转。不过这里更重要的是，即使设置了此项，在某些播放器上，画面依然会有90度的旋转（比如将在手机上正常播放的视频导入到PC中进行播放，或者嵌入H5的video标签中），这可是为什么呢？注意setOrientationHint的说明：Note that some video players may choose to ignore the compostion matrix in a video during playback. 那么如何做到在所有播放器上都能以正常方向播放呢？稍等，后续专门对其进行说明。&lt;br&gt;&lt;strong&gt;Step 2：&lt;/strong&gt;&lt;br&gt;setAudioSource(MediaRecorder.AudioSource.VOICE_RECOGNITION)，VOICE_RECOGNITION相比于MIC会根据语音识别的需要做一些调谐，当然，这需要在系统支持的情况下。&lt;br&gt;setVideoSource自然是VideoSource.CAMERA，只是在此两项设置必须在设置编码器之前设置，这无需说明。&lt;br&gt;&lt;strong&gt;Step 3：&lt;/strong&gt;&lt;br&gt;setOutputFormat需要在Step 2之后，并且在prepare()之前。这里采用OutputFormat.MPEG_4格式。&lt;br&gt;setVideoSize需要权衡的因素较多，主要包括三方面：MediaRecorder支持的录制尺寸、视频文件的大小以及兼容不同Android机型。这里采用640 &lt;em&gt; 480（微信小视频的尺寸是320&lt;/em&gt;240），文件大小在500-1000kb之间，并且市面上99%以上机型支持此录制尺寸。&lt;br&gt;setVideoEncodingBitRate与视频的清晰度有关，设置此参数需要权衡清晰度与文件大小的关系。太高，文件大不易传输；太低，文件清晰度低，识别率低。需要根据实际业务场景灵活调整。&lt;br&gt;setVideoEncoder采用H264编码，MPEG4、H263、H264等不同编码的差别比较可参考&lt;a href=&quot;http://blog.csdn.net/wcl0715/article/details/676137，实际使用中，H264的压缩率较高，推荐使用。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/wcl0715/article/details/676137，实际使用中，H264的压缩率较高，推荐使用。&lt;/a&gt;&lt;br&gt;setAudioEncoder采用AudioEncoder.AAC，该设置主要是考虑其通用性、兼容性。&lt;br&gt;&lt;strong&gt;Step 4：&lt;/strong&gt;&lt;br&gt;setMaxFileSize指定录制文件的大小限制，当然还可以限制其最大录制时间。&lt;br&gt;setOutputFile指定输出视频的路径。&lt;br&gt;setOnErrorListener指定错误监听器。&lt;/p&gt;
&lt;p&gt;在完成上述配置之后，即可准备MediaRecorder，并在返回成功后开始视频录制。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private boolean prepareConfiguredMediaRecorder() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Step 5: Prepare configured MediaRecorder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mMediaRecorder.prepare();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        releaseMediaRecorder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;四、视频文件旋转&quot;&gt;&lt;a href=&quot;#四、视频文件旋转&quot; class=&quot;headerlink&quot; title=&quot;四、视频文件旋转&quot;&gt;&lt;/a&gt;四、视频文件旋转&lt;/h2&gt;&lt;p&gt;第三节中Step 1提到对视频文件的旋转，因为某些播放器会忽略录制视频时的配置参数，因此可尝试通过第三方库对视频文件进行旋转，例如：OpenCV，fastCV等，在Camera对象的Camera.PreviewCallback中截取每帧数据byte[] data，然后对其进行处理，然后输出。该方法需要考虑处理方法的高效性，在编程时一般采用NDK，在C++中完成关键的处理，这里贴出fastCV中该处理方法的逻辑。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void onPreviewFrame( byte[] data, Camera c ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Increment FPS counter for camera.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    util.cameraFrameTick();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Perform processing on the camera preview data.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    update( data, mDesiredWidth, mDesiredHeight );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Simple IIR filter on time.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mProcessTime = util.getFastCVProcessTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if( c != null ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // with buffer requires addbuffer each callback frame.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c.addCallbackBuffer( mPreviewBuffer );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c.setPreviewCallbackWithBuffer( this );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Mark dirty for render.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    requestRender();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，update为native方法，其实现由jni中对应的文件完成，其中调用了libfastcv.a中相应的API。这里涉及NDK编程的基本方法步骤：（1）开发环境；（2）编写Java代码、C/C++代码；（3）编译C/C++文件生成.so库；（4）重新编译工程，生成apk。由于本章不重点讲述NDK，这里不再展开。&lt;br&gt;除上述方法以外，笔者采用了另外一种思路进行了探索，上述方法处理的数据为每帧图像数据，可以理解为在线处理，而如果在录制完成之后再处理，可以理解为离线处理。这里采用了第三方库mp4parser，mp4parser是一款支持在Android中进行视频分割的库，这里通过其进行视频旋转。至于具体效果如何，读者有兴趣可自行尝试，这里留个悬念。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private boolean rotateVideoFileWithClockwiseDegree(String sourceFilePath, int degree) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!isFileAndDegreeValid(sourceFilePath, degree)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rotateVideoFile(sourceFilePath, degree);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对输入参数进行合法性检测之后，根据检测结果判断是否进行旋转。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private boolean isFileAndDegreeValid(String sourceFilePath, int degree) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(sourceFilePath == null || (!sourceFilePath.endsWith(&amp;quot;.mp4&amp;quot;)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              || (!new File(sourceFilePath).exists())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (degree == 0 || (degree % 90 != 0)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void rotateVideoFile(String sourceFilePath, int degree) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;TrackBox&amp;gt; trackBoxes = getTrackBoxesOfVideoFileByPath(sourceFilePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Movie rotatedMovie = getRotatedMovieOfTrackBox(trackBoxes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writeMovieToModifiedFile(rotatedMovie);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过mp4parser旋转视频主要分为三步：（1）获取视频文件对应的TrackBoxes；（2）根据TrackBoxes获取旋转后的Movie对象；（3）将Movie对象写入文件。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private List&amp;lt;TrackBox&amp;gt; getTrackBoxesOfVideoFileByPath(String sourceFilePath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IsoFile isoFile = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;TrackBox&amp;gt; trackBoxes = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isoFile = new IsoFile(sourceFilePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trackBoxes = isoFile.getMovieBox().getBoxes(TrackBox.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isoFile.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return trackBoxes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private Movie getRotatedMovieOfTrackBox(List&amp;lt;TrackBox&amp;gt; trackBoxes) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Movie rotatedMovie = new Movie();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 旋转&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (TrackBox trackBox : trackBoxes) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trackBox.getTrackHeaderBox().setMatrix(Matrix.ROTATE_90);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rotatedMovie.addTrack(new Mp4TrackImpl(trackBox));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return rotatedMovie;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void writeMovieToModifiedFile(Movie movie) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Container container = new DefaultMp4Builder().build(movie);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    File modifiedVideoFile = new File(videoFilePath.replace(&amp;quot;.mp4&amp;quot;, &amp;quot;_MOD.mp4&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FileOutputStream fos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fos = new FileOutputStream(modifiedVideoFile);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        WritableByteChannel bb = Channels.newChannel(fos);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        container.writeContainer(bb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 关闭文件流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fos.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;本文对Android视频录制中常见的问题进行了说明，转载请注明出处（虽然也没什么转载）。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文分享自己在视频录制播放过程中遇到的一些问题，主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视频录制流程&lt;/li&gt;
&lt;li&gt;视频预览及SurfaceHolder&lt;/li&gt;
&lt;li&gt;视频清晰度及文件大小&lt;/li&gt;
&lt;li&gt;视频文件旋转&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=
    
    </summary>
    
      <category term="日志" scheme="http://yhthu.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Android" scheme="http://yhthu.com/tags/Android/"/>
    
      <category term="视频录制播放" scheme="http://yhthu.com/tags/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%E6%92%AD%E6%94%BE/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</title>
    <link href="http://yhthu.com/2016/04/14/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A5Volley%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E8%AF%B7%E6%B1%82%E5%8F%8A%E5%B1%95%E7%A4%BA%E4%B8%BA%E4%BE%8B%E7%90%86%E8%A7%A3Volley%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yhthu.com/2016/04/14/Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计/</id>
    <published>2016-04-14T11:59:46.343Z</published>
    <updated>2016-04-14T11:59:52.157Z</updated>
    
    <content type="html">&lt;p&gt;Volley是由Google开源的、用于Android平台上的网络通信库。Volley通过优化Android的网络请求流程，形成了以&lt;strong&gt;Request-RequestQueue-Response&lt;/strong&gt;为主线的网络访问链，使得Android网络访问变得&lt;strong&gt;简单、高效、扩展性强&lt;/strong&gt;。（根据RTFSC原则，强烈建议Android的童鞋学习下Volley的架构设计）下面将以ImageLoader、ImageCache、ImageRequest及NetworkImageView为例，对此进行说明。&lt;/p&gt;
&lt;h2 id=&quot;一、ImageCache-ImageLoader-ImageListener&quot;&gt;&lt;a href=&quot;#一、ImageCache-ImageLoader-ImageListener&quot; class=&quot;headerlink&quot; title=&quot;一、ImageCache-ImageLoader-ImageListener&quot;&gt;&lt;/a&gt;一、ImageCache-ImageLoader-ImageListener&lt;/h2&gt;&lt;p&gt;对于图片的下载，这里采用自底向上的分析方法，即首先明确Volley加载图片是通过ImageLoader的get方法实现的，然后依次说明该方法需要的参数的构成。get方法有三种重载形式（早一些的版本没有第三种）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public ImageContainer get(String requestUrl, final ImageListener listener);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight, ScaleType scaleType);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 不过前两种都是通过三种方法实现的，这里以第三种方法为例进行说明：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public ImageContainer get(String requestUrl, ImageListener imageListener,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int maxWidth, int maxHeight, ScaleType scaleType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // only fulfill requests that were initiated from the main thread.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    throwIfNotOnMainThread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Try to look up the request in the cache of remote images.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (cachedBitmap != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Return the cached bitmap.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageListener.onResponse(container, true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return container;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // The bitmap did not exist in the cache, fetch it!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ImageContainer imageContainer =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            new ImageContainer(null, requestUrl, cacheKey, imageListener);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Update the caller to let them know that they should use the default bitmap.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageListener.onResponse(imageContainer, true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Check to see if a request is already in-flight.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BatchedImageRequest request = mInFlightRequests.get(cacheKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (request != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // If it is, add this request to the list of listeners.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request.addContainer(imageContainer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return imageContainer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // The request is not already in flight. Send the new request to the network and&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // track it.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Request&amp;lt;Bitmap&amp;gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cacheKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mRequestQueue.add(newRequest);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mInFlightRequests.put(cacheKey,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            new BatchedImageRequest(newRequest, imageContainer));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return imageContainer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述代码的逻辑非常清晰，可以下面的流程图来表示，不再赘述：&lt;br&gt;&lt;img src=&quot;/img/20151212-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于StringRequest、JsonRequest，Volley也采用了同样的处理流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从get方法的形参入手，这里着重说明ImageListener（其它的形参见名知义）。ImageListener是ImageLoader的内部接口，继承于ErrorListener，需要实现的方法为onResponse：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface ImageListener extends ErrorListener &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Listens for non-error changes to the loading of the image request.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param response Holds all information pertaining to the request, as well&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * as the bitmap (if it is loaded).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param isImmediate True if this was called during ImageLoader.get() variants.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * This can be used to differentiate between a cached image loading and a network&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * image loading in order to, for example, run an animation to fade in network loaded&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * images.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onResponse(ImageContainer response, boolean isImmediate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ImageLoader还提供了静态方法getImageListener来获取ImageListener实例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static ImageListener getImageListener(final ImageView view,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        final int defaultImageResId, final int errorImageResId) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return new ImageListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public void onErrorResponse(VolleyError error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (errorImageResId != 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                view.setImageResource(errorImageResId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public void onResponse(ImageContainer response, boolean isImmediate) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (response.getBitmap() != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                view.setImageBitmap(response.getBitmap());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else if (defaultImageResId != 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                view.setImageResource(defaultImageResId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从代码很容易看出，ImageListener就是Image请求返回时的回调接口，onErrorResponse和onResponse分别实现了请求失败和成功时加载对应的图片。&lt;br&gt;分析完get方法执行的流程及形参之后，我们回到ImageLoader本身。ImageLoader的构造函数如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Constructs a new ImageLoader.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param queue The RequestQueue to use for making image requests.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param imageCache The cache to use as an L1 cache.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public ImageLoader(RequestQueue queue, ImageCache imageCache) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mRequestQueue = queue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mCache = imageCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样，从ImageLoader的形参入手，这里需要传入RequestQueue和ImageCache的实例对象。RequestQueue即整个Volley的核心请求队列，在使用Volley时第一个初始化的对象。其构造方法在Volley源码toolbox文件夹下的Volley工具类中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Volley &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /** Default on-disk cache directory. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static final String DEFAULT_CACHE_DIR = &amp;quot;volley&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Creates a default instance of the worker pool and calls &amp;#123;@link RequestQueue#start()&amp;#125; on it.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param context A &amp;#123;@link Context&amp;#125; to use for creating the cache dir.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param stack An &amp;#123;@link HttpStack&amp;#125; to use for the network, or null for default.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return A started &amp;#123;@link RequestQueue&amp;#125; instance.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static RequestQueue newRequestQueue(Context context, HttpStack stack) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String userAgent = &amp;quot;volley/0&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String packageName = context.getPackageName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            userAgent = packageName + &amp;quot;/&amp;quot; + info.versionCode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; catch (NameNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (stack == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (Build.VERSION.SDK_INT &amp;gt;= 9) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack = new HurlStack();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // Prior to Gingerbread, HttpUrlConnection was unreliable.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Network network = new BasicNetwork(stack);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return queue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Creates a default instance of the worker pool and calls &amp;#123;@link RequestQueue#start()&amp;#125; on it.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param context A &amp;#123;@link Context&amp;#125; to use for creating the cache dir.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return A started &amp;#123;@link RequestQueue&amp;#125; instance.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static RequestQueue newRequestQueue(Context context) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return newRequestQueue(context, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里重点说明ImageCache，即图片的缓存。ImageCache同样是定义在ImageLoader中的接口（从这里也可以看出volley的高可扩展性）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Simple cache adapter interface. If provided to the ImageLoader, it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * will be used as an L1 cache before dispatch to Volley. Implementations&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * must not block. Implementation with an LruCache is recommended.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface ImageCache &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Bitmap getBitmap(String url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void putBitmap(String url, Bitmap bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;根据注释可以看出，推荐使用LruCache。对于LruCache，前面的博文《Android开发笔记——ListView模块、缓存及性能》已做过详细介绍，其通过维护一个强引用来限制内容数量，每当Item被访问的时候，此Item就会移动到队列的头部。当cache已满时加入新的item，在队列尾部的item会被回收。&lt;br&gt;不过，在某些应用场景下，只使用LruCache还不够。当应用退出后，LruCache清空，重新加载时，缓存的图片依然需要重新加载。这里需要使用DiskLruCache，即磁盘缓存，原理与《Android开发笔记——ListView模块、缓存及性能》中SD卡存储配合LruCache相同，但DiskLruCache实现更为合理，获得Google官方认证。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于DiskLruCache的源码解析，推荐Android DiskLruCache完全解析，硬盘缓存的最佳方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，建议配合LruCache和DiskLruCache，以及Volley的请求缓存，形成图片三级缓存。LruCache和DiskLruCache的初始化方法分别如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int maxSize = (int) (Runtime.getRuntime().maxMemory() / 8);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 实例化LruCaceh对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mLruCache = new LruCache&amp;lt;String, Bitmap&amp;gt;(maxSize) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     protected int sizeOf(String key, Bitmap bitmap) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return bitmap.getRowBytes() * bitmap.getHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 实例化DiskLruCache对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 获取DiskLruCahce对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mDiskLruCache = DiskLruCache.open(getDiskCacheDir(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    context.getApplicationContext(), &amp;quot;younghao&amp;quot;), getAppVersion(context), 1, DISKMAXSIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125; catch (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ImageCaches实现getBitmap和putBitmap方法时，可以使用LruCache和DiskLruCache实例高效处理图片。存入缓存时，先存入到LruCache中，然后判断是否存在DiskLruCache缓存，若没有存入；读取图片时，先从LruCache中取，没有时再从DiskLruCache中取（取出之后，顺便存入LruCache中，供下次访问时使用，不再访问DiskLruCache）。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 存入缓存（内存缓存，磁盘缓存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void putBitmap(String url, Bitmap bitmap) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 存入LruCache缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mLruCache.put(url, bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 判断是否存在DiskLruCache缓存，若没有存入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String key = MD5Utils.md5(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (mDiskLruCache.get(key) == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            DiskLruCache.Editor editor = mDiskLruCache.edit(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (editor != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                OutputStream outputStream = editor.newOutputStream(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (bitmap.compress(CompressFormat.JPEG, 100, outputStream)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    editor.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    editor.abort();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mDiskLruCache.flush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 从缓存（内存缓存，磁盘缓存）中获取Bitmap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public Bitmap getBitmap(String url) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mLruCache.get(url) != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 从LruCache缓存中取&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.i(TAG, &amp;quot;从LruCahce获取&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return mLruCache.get(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String key = MD5Utils.md5(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (mDiskLruCache.get(key) != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // 从DiskLruCahce取&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Bitmap bitmap = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (snapshot != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    bitmap = BitmapFactory.decodeStream(snapshot.getInputStream(0));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    // 存入LruCache缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    mLruCache.put(url, bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Log.i(TAG, &amp;quot;从DiskLruCahce获取&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return bitmap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; catch (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至此，通过volley加载图片的方法已完成。调用方法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 获取ImageCache实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImageCacheUtil imageCacheUtil = ImageCacheUtil.instance(context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 初始化ImageLoader实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImageLoader imageLoader = new ImageLoader(requestQueue, imageCacheUtil);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取ImageListener实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImageListener listener = ImageLoader.getImageListener(imageRequestBean.getImageView(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageRequestBean.getDefaultImageID(), imageRequestBean.getErrorImageID());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 发送请求图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;imageLoader.get(imageRequestBean.getUrl(),                 listener,imageRequestBean.getMaxWidth(), imageRequestBean.getMaxHeight());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、对Volley的架构的理解&quot;&gt;&lt;a href=&quot;#二、对Volley的架构的理解&quot; class=&quot;headerlink&quot; title=&quot;二、对Volley的架构的理解&quot;&gt;&lt;/a&gt;二、对Volley的架构的理解&lt;/h2&gt;&lt;p&gt;如果有童鞋能读到这里，那么对Volley的网络请求处理逻辑应该已经有了一定的认识。下面将通过Volley的官方文档对Volley的架构作进一步的说明。Volley提供了对于网络请求的自动调度，能够处理高并发网络链接，拥有透明的磁盘及内存缓存，支持请求优先级、取消请求、异步网络请求等。Volley的源码地址为：&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/volley（git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://android.googlesource.com/platform/frameworks/volley（git&lt;/a&gt; clone），不过考虑到网络问题，也可到github上下载：&lt;a href=&quot;https://github.com/mcxiaoke/android-volley.git（git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mcxiaoke/android-volley.git（git&lt;/a&gt; clone）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2013年Volley发布会视频：Google I/O 2013 - Volley: Easy, Fast Networking for Android（YouTube，你懂）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-1-发送一个简单的请求&quot;&gt;&lt;a href=&quot;#2-1-发送一个简单的请求&quot; class=&quot;headerlink&quot; title=&quot;2.1 发送一个简单的请求&quot;&gt;&lt;/a&gt;2.1 发送一个简单的请求&lt;/h3&gt;&lt;p&gt;先贴一张官网的图，后面做解释。&lt;br&gt;&lt;img src=&quot;/img/20151212-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这张图展示了Volley的核心架构，主要包含了以下类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Volley。前面已经提到，位于toolbox文件中，是创建请求队列的工具类；&lt;/li&gt;
&lt;li&gt;Request。实现了Comparable&lt;request&lt;t&gt;&amp;gt;接口的抽象类，Volley中的请求都是继承于该类实现的，Request支持八种请求方法。&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public abstract class Request&amp;lt;T&amp;gt; implements Comparable&amp;lt;Request&amp;lt;T&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/request&lt;t&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Supported request methods.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface Method &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int DEPRECATED_GET_OR_POST = -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int GET = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int POST = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int PUT = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int DELETE = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int HEAD = 4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int OPTIONS = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int TRACE = 6;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int PATCH = 7;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;RequestQueue。Volley的核心，代表整个请求队列。需要重点说明的是其成员变量，包含了&lt;ul&gt;
&lt;li&gt;CacheDispatcher（处理缓存请求的调度线程）&lt;/li&gt;
&lt;li&gt;NetworkDispatcher[]（处理网络请求的调用线程组）&lt;/li&gt;
&lt;li&gt;ResponseDelivery（网络请求返回接口分发）&lt;/li&gt;
&lt;li&gt;Network （执行网络请求的网络接口）&lt;/li&gt;
&lt;li&gt;Cache（缓存请求的接口，PS：上一节说的是缓存图片）&lt;/li&gt;
&lt;li&gt;DEFAULT_NETWORK_THREAD_POOL_SIZE（默认线程池数目，至于为什么是4？这是一个经验值，在自己实际应用中，可根据任务、网络状况以及设备等灵活设置）&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue&lt;request&lt;?&gt;&amp;gt; （基于优先级阻塞的请求队列，包含等待的和正在执行的）、&lt;/request&lt;?&gt;&lt;/li&gt;
&lt;li&gt;Set&lt;request&lt;?&gt;&amp;gt; mCurrentRequests （正在处理的请求）&lt;/request&lt;?&gt;&lt;/li&gt;
&lt;li&gt;Map&lt;string, queue&lt;request&lt;?=&quot;&quot;&gt;&amp;gt;&amp;gt; mWaitingRequests（正在等待的请求）&lt;/string,&gt;&lt;/li&gt;
&lt;li&gt;AtomicInteger mSequenceGenerator（原子的，避免并发访问）&lt;/li&gt;
&lt;li&gt;RequestFinishedListener&lt;t&gt;接口（请求完成的回调）&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/** Callback interface for completed requests. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static interface RequestFinishedListener&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /** Called when a request has finished processing. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onRequestFinished(Request&amp;lt;T&amp;gt; request);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** Used for generating monotonically-increasing sequence numbers for requests. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private AtomicInteger mSequenceGenerator = new AtomicInteger();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Staging area for requests that already have a duplicate request in flight.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;ul&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     &amp;lt;li&amp;gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          key.&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     &amp;lt;li&amp;gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          is &amp;lt;em&amp;gt;not&amp;lt;/em&amp;gt; contained in that list. Is null if no requests are staged.&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final Map&amp;lt;String, Queue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt;&amp;gt; mWaitingRequests =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new HashMap&amp;lt;String, Queue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * The set of all requests currently being processed by this RequestQueue. A Request&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * will be in this set if it is waiting in any queue or currently being processed by&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * any dispatcher.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final Set&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mCurrentRequests = new HashSet&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** The cache triage queue. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final PriorityBlockingQueue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mCacheQueue =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    new PriorityBlockingQueue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** The queue of requests that are actually going out to the network. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final PriorityBlockingQueue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mNetworkQueue =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    new PriorityBlockingQueue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** Number of network request dispatcher threads to start. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** Cache interface for retrieving and storing responses. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final Cache mCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** Network interface for performing requests. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final Network mNetwork;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** Response delivery mechanism. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final ResponseDelivery mDelivery;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** The network dispatchers. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private NetworkDispatcher[] mDispatchers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/** The cache dispatcher. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private CacheDispatcher mCacheDispatcher;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private List&amp;lt;RequestFinishedListener&amp;gt; mFinishedListeners =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new ArrayList&amp;lt;RequestFinishedListener&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/t&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送一个请求，只需将请求添加到请求队列即可。官网的一段示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;final TextView mTextView = (TextView) findViewById(R.id.text);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Instantiate the RequestQueue.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RequestQueue queue = Volley.newRequestQueue(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String url =&amp;quot;http://www.google.com&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Request a string response from the provided URL.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringRequest stringRequest = new StringRequest(Request.Method.GET, url,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            new Response.Listener&amp;lt;String&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onResponse(String response) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Display the first 500 characters of the response string.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mTextView.setText(&amp;quot;Response is: &amp;quot;+ response.substring(0,500));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, new Response.ErrorListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onErrorResponse(VolleyError error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mTextView.setText(&amp;quot;That didn&amp;apos;t work!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Add the request to the RequestQueue.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.add(stringRequest);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;取消请求同样简单，通过TAG来找到特定的request，然后取消。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static final String TAG = &amp;quot;MyTag&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringRequest stringRequest; // Assume this exists.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RequestQueue mRequestQueue;  // Assume this exists.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Set the tag on the request.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringRequest.setTag(TAG);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Add the request to the RequestQueue.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mRequestQueue.add(stringRequest);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;protected void onStop () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.onStop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mRequestQueue != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mRequestQueue.cancelAll(TAG);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-2-创建一个RequestQueue&quot;&gt;&lt;a href=&quot;#2-2-创建一个RequestQueue&quot; class=&quot;headerlink&quot; title=&quot;2.2 创建一个RequestQueue&quot;&gt;&lt;/a&gt;2.2 创建一个RequestQueue&lt;/h3&gt;&lt;p&gt; 在2.1节中，使用了默认的RequestQueue构造器（即通过Volley工具类），但Volley支持自定义NetWork和Cache，实现更加个性化的网络和缓存。另外一个需要注意的问题就是单例模式，为了高效的使用RequestQueue，官方建议在整个应用的生命周期内只使用一个RequestQueue实例。&lt;strong&gt;不过注意到很多中文的帖子使用继承Application，在Application的onCreate()方法中创建RequestQueue，官方并不鼓励这种做法，使用静态的的单例能够以更加模块化的方式实现同样的功能。&lt;/strong&gt;核心的思想是RequestQueue应该被Application的context实例，而不是某个Activity的context。（getApplicationContext()与getContext()方法的区别）&lt;/p&gt;
&lt;h3 id=&quot;2-3-创建一个标准的请求&quot;&gt;&lt;a href=&quot;#2-3-创建一个标准的请求&quot; class=&quot;headerlink&quot; title=&quot;2.3 创建一个标准的请求&quot;&gt;&lt;/a&gt;2.3 创建一个标准的请求&lt;/h3&gt;&lt;p&gt;继承Request的请求类型主要有：StringRequest、ImageRequest、JsonObjectRequest和JsonArrayRequest（JsonRequest的子类），第一节对ImageRequest进行了详细的说明，这里主要说明JsonObjectRequest和JsonArrayRequest，因为在实际项目中，通Json传递数据可能是目前最常见的方式。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TextView mTxtDisplay;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImageView mImageView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mTxtDisplay = (TextView) findViewById(R.id.txtDisplay);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String url = &amp;quot;http://my-json-feed&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JsonObjectRequest jsObjRequest = new JsonObjectRequest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (Request.Method.GET, url, null, new Response.Listener&amp;lt;JSONObject&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onResponse(JSONObject response) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mTxtDisplay.setText(&amp;quot;Response: &amp;quot; + response.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, new Response.ErrorListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onErrorResponse(VolleyError error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // TODO Auto-generated method stub&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Access the RequestQueue through your singleton class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySingleton.getInstance(this).addToRequestQueue(jsObjRequest);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 官方的示例代码比较简单。不过可以关注下Request的方法，它抽象了StringRequest、ImageRequest、JsonRequest的公共特征，这种结构设计的思路值得学习。&lt;/p&gt;
&lt;p&gt;最后推荐几个博客作为参考：&lt;br&gt;&lt;a href=&quot;http://p.codekk.com/blogs/detail/54cfab086c4761e5001b2542&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volley 源码解析&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://bxbxbai.github.io/2014/09/14/android-working-with-volley/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android库Volley的使用介绍&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/17656437&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Volley完全解析(四)，带你从源码的角度理解Volley（Volley系列文章）&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Volley是由Google开源的、用于Android平台上的网络通信库。Volley通过优化Android的网络请求流程，形成了以&lt;strong&gt;Request-RequestQueue-Response&lt;/strong&gt;为主线的网络访问链，使得Android网络访问变得
    
    </summary>
    
      <category term="日志" scheme="http://yhthu.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="图片缓存" scheme="http://yhthu.com/tags/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/"/>
    
      <category term="Volley架构" scheme="http://yhthu.com/tags/Volley%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——ListView模块、缓存及性能</title>
    <link href="http://yhthu.com/2016/04/14/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ListView%E6%A8%A1%E5%9D%97%E3%80%81%E7%BC%93%E5%AD%98%E5%8F%8A%E6%80%A7%E8%83%BD/"/>
    <id>http://yhthu.com/2016/04/14/Android开发笔记——ListView模块、缓存及性能/</id>
    <published>2016-04-14T08:09:16.632Z</published>
    <updated>2016-04-14T08:26:39.671Z</updated>
    
    <content type="html">&lt;p&gt;ListView是Android开发中最常用的组件之一。本文将重点说明如何正确使用ListView，以及使用过程中可能遇到的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ListView开发模块&lt;/li&gt;
&lt;li&gt;图片缓存&lt;/li&gt;
&lt;li&gt;可能遇到的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、ListView开发模块&quot;&gt;&lt;a href=&quot;#一、ListView开发模块&quot; class=&quot;headerlink&quot; title=&quot;一、ListView开发模块&quot;&gt;&lt;/a&gt;一、ListView开发模块&lt;/h2&gt;&lt;p&gt;从项目实践的角度来看，ListView适合“自底向上”的开发模式，即从每个条目的显示组件，到对其进行控制的数据结构，最后通过Activity等进行使用。主要包括以下模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是item组件，即用于每项布局输出的xml文件。Android SDK中有simple_list_item_1、simple_list_item_2可用，当需要比较丰富的显示效果时，一般通过自定义xml实现。本文以论坛的格式进行说明，主要包括发帖人头像、用户名，帖子的标题、内容、最后回复时间、编辑、收藏、回复等内容，布局文件比较简单，这里截取其中一项显示，用以说明：&lt;br&gt;&lt;img src=&quot;/img/20151023-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其次是父对象layout文件，即用于Activity或者Fragment的布局输出文件，一般在此输出文件中包含ListView。当然，如果采用ListFragment或ListActivity，并不需要再显示的定义ListView组件。本文中采用Fragment默认的输出文件，当然，也可以采用自定义的布局文件。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;ListView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:id=&amp;quot;@+id/topic_list&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:layout_width=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:layout_height=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:cacheColorHint=&amp;quot;@android:color/transparent&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:divider=&amp;quot;@color/topic_divider_color&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:dividerHeight=&amp;quot;1px&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android:listSelector=&amp;quot;@android:color/transparent&amp;quot; &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/ListView&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义数据结构（容器），即用于持有单个Item的数据，可以是简单的String，也可以通过抽象Items所需字段组成一个类，抽象的原则是与Item中的组件对应。本文中上图涉及多个字段，因此通过抽象组件形成BBSTopicItem类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;列表适配器。决定每行Item中具体显示什么内容，以怎样的样式显示等，通常通过继承ArrayAdapter、SimpleAdapter等实现。本文定义BBSTopicAdapter，继承于ArrayAdapter&lt;bbstopicitem&gt;。&lt;/bbstopicitem&gt;&lt;/li&gt;
&lt;li&gt;最后，需要定义一个Activity或Fragment来使用上述模块。需要说明的是，ListView可以直接被ListActivity或者ListFragment使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上五个模块就是使用ListView的&lt;strong&gt;基本逻辑框架&lt;/strong&gt;，开发过程中，需要时刻理清它们之间的关系。 &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二、图片缓存及相关&quot;&gt;&lt;a href=&quot;#二、图片缓存及相关&quot; class=&quot;headerlink&quot; title=&quot;二、图片缓存及相关&quot;&gt;&lt;/a&gt;二、图片缓存及相关&lt;/h2&gt;&lt;p&gt;在ListView中显示图片是比较常见的应用场景，但加载图片一般需要通过缓存来进行处理。由于虚拟机的heapsize默认为16M：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AndroidRuntime.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int AndroidRuntime::startVM(JavaVM** pJavaVM, JNIEnv** pEnv) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    property_get(&amp;quot;dalvik.vm.heapsize&amp;quot;, heapsizeOptsBuf+4, &amp;quot;16M&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（厂商一般会修改为32M，后面会说到这个数值）&lt;br&gt;在操作大尺寸图片时无法分配所需内存，就会引起OOM。因此，使用LruCache来缓存图片是常见的做法。但在其使用过程中，也需要注意一些问题，比如使用线程池下载图片，使用SD卡缓存，ListView滑动流畅性，图片显示错乱等，下面对这些问题进行说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先是LruCache，该类在android-support-v4的包中提供&lt;/strong&gt;&lt;br&gt;主要算法原理是把最近使用的对象用强引用存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。&lt;/p&gt;
&lt;p&gt;以前经常会使用一种非常流行的内存缓存技术的实现，即软引用或弱引用 (SoftReference or WeakReference)。但是现在已经不再推荐使用这种方式了，因为从 Android 2.3 (API Level 9)开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠。另外，Android 3.0 (API Level 11)中，图片的数据会存储在本地的内存当中，因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃。&lt;/p&gt;
&lt;p&gt;那么，怎样确定一个合适的缓存大小给LruCache呢？有以下多个因素应该放入考虑范围内，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备可以为每个应用程序分配多大的内存？&lt;/li&gt;
&lt;li&gt;设备屏幕上一次最多能显示多少张图片？有多少图片需要进行预加载？&lt;/li&gt;
&lt;li&gt;设备的屏幕大小和分辨率分别是多少？一个超高分辨率的设备（例如 Galaxy Nexus)比起一个较低分辨率的设备（例如 Nexus S），在持有相同数量图片的时候，需要更大的缓存空间。&lt;/li&gt;
&lt;li&gt;图片的尺寸和大小，还有每张图片会占据多少内存空间？&lt;/li&gt;
&lt;li&gt;图片被访问的频率有多高？是否有一些图片的访问频率比其它图片要高？如果有的话，应该让一些图片常驻在内存当中，或者使用多个LruCache 对象来区分不同组的图片。&lt;/li&gt;
&lt;li&gt;是否能维持好数量和质量之间的平衡吗？有些时候，存储多个低像素的图片，而在后台去开线程加载高像素的图片会更加的有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;并没有一个指定的缓存大小可以满足所有的应用程序&lt;/strong&gt;，通常需要分析程序内存的使用情况，然后制定出一个合适的解决方案。缓存太小，有可能造成图片频繁地被释放和重新加载；而缓存太大，则有可能还是会引起 java.lang.OutOfMemory 异常。&lt;br&gt;不过，读者可能会在不同的地方遇到类似下面这段定义LruCache的代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public ImageDownLoader(Context context)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int maxMemory = (int) Runtime.getRuntime().maxMemory();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int mCacheSize = maxMemory / 8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mMemoryCache = new LruCache&amp;lt;String, Bitmap&amp;gt;(mCacheSize)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        protected int sizeOf(String key, Bitmap value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return value.getRowBytes() * value.getHeight();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用线程池管理图片下载任务&lt;/strong&gt;&lt;br&gt;线程池自然是为了限制系统中执行线程的数量，通常的一种比较低效的做法是为每一张图片下载开启一个新线程（new thread），线程的创建和销毁将造成极大的性能损耗，而对服务器来讲，维护过多的线程将造成内存消耗过大。总的来讲，使用线程池是执行此类任务的一个基本做法。Java中线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口是ExecutorService。配置线程池是略显复杂，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是最优的。在Executors类里提供了一些静态工厂，生成一些常用的线程池。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;newSingleThreadExecutor创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。&lt;/li&gt;
&lt;li&gt;newCachedThreadPool 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，&lt;br&gt;那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过下面的代码创建固定大小的线程池：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private ExecutorService getThreadPools()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(mImageThreadPool == null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        synchronized(ExecutorService.class)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(mImageThreadPool == null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mImageThreadPool = Executors.newFixedThreadPool(4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return mImageThreadPool;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(本段代码来自互联网)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于固定大小的线程池，关键是需要根据实际应用场景设置线程数量，既快速有效的执行下载任务，又不造成资源浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. SD卡存储配合LruCache&lt;/strong&gt;&lt;br&gt;使用SD卡存储下载的图片有多方面的好处，提高图片加载速度（从本地加载肯定比网络要快）、节约用户流量等，因此，除了LruCache，一般还会将图片存储在本地SD卡。因此，加载图片的顺序应该是&lt;/p&gt;
&lt;p&gt;　　a. 首先从LruCache中获取图片；&lt;br&gt;　　b. 如果a的返回值为null，则检查SD卡是否存在图片；&lt;br&gt;　　c. 如果a、b的返回值都为null，则通过网络进行下载。&lt;/p&gt;
&lt;p&gt;　　用代码表述上述逻辑为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Bitmap bitmap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (getBitmapFromMemCache(url) != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap = getBitmapFromMemCache(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else if (fileUtils.isFileExists(url) &amp;amp;&amp;amp; fileUtils.getFileSize(url) != 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap = fileUtils.getBitmapFromSD(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap = getBitmapFormUrl(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return bitmap;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Tip：如果通过HttpURLConnection下载图片，需要注意一个小问题，如果设置HttpURLConnection对象的DoOutput属性为true（con.setDoOutput(true)），在Android4.0以后，会解析为post请求，导致filenotfound异常（获取图片应该是get请求）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. ListView滑动停止下载&lt;/strong&gt;&lt;br&gt;滑动时停止下载也是提高用户体验的方式之一，因为如果在ListView滑动过程中执行下载任务，将会使得ListView出现卡顿。监听滑动状态改变的方法是&lt;strong&gt;onScrollStateChanged(AbsListView view, int scrollState)&lt;/strong&gt;，该方法在&lt;strong&gt;OnScrollListener&lt;/strong&gt;接口中定义的，而OnScrollListener是&lt;strong&gt;AbsListView&lt;/strong&gt;中为了在列表或网格滚动时执行回调函数而定义的接口。（强烈建议做ListView相关应用的读者熟悉一下AbsListView的源码）&lt;/p&gt;
&lt;p&gt;为了实现下载任务与滑动状态的关联，在自定义列表适配器中实现了OnScrollListener接口，在onScrollStateChanged方法中根据scrollState执行相应的下载任务操作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void onScrollStateChanged(AbsListView view, int scrollState) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.scrollState = scrollState;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        showImage(mFirstVisibleItem, mVisibleItemCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cancelTask();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（本段代码来自互联网）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 图片显示错乱&lt;/strong&gt;&lt;br&gt;这是一个比较老生常谈的问题，在百度搜索一下“listview图片错位”会见到一大片帖子在讨论这个问题，这里不再赘述，推荐几个比较靠谱链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lesliefang/p/3619223.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/lesliefang/p/3619223.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/shineflowers/article/details/41744477&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/shineflowers/article/details/41744477&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总的来讲，图片缓存是Android开发中比较有意思的一个话题，常用的图片缓存开源库有ImageLoader、Picasso、Glide等，最近由Facebook开源了Fresco（&lt;a href=&quot;http://www.fresco-cn.org/）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.fresco-cn.org/）&lt;/a&gt; ，根据介绍，它能够从网络、本地存储和本地资源中加载图片。同时，为了节省数据和CPU，它拥有三级缓存。此外，Fresco在显示方面是用了Drawees，可以显示占位符，直到图片加载完成。而当图片从屏幕上消失时，会自动释放图片所占的内存。这里推荐一个关于Android三大图片缓存原理、特性对比的链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.csdn.net/article/2015-10-21/2825984#rd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.csdn.net/article/2015-10-21/2825984#rd&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、可能遇到的问题&quot;&gt;&lt;a href=&quot;#三、可能遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;三、可能遇到的问题&quot;&gt;&lt;/a&gt;三、可能遇到的问题&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;1. notifyDataSetChanged与局部更新&lt;/strong&gt;&lt;br&gt; 首先举一个栗子：QQ空间或者朋友圈的点赞功能，点赞之后页面会马上刷新，但不会影响本条目以外的其他条目的显示。换句话说，它使用了局部更新，而非notifyDataSetChanged。在了解notifyDataSetChanged与局部更新区别时，需要先对以下问题作出解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;notifyDataSetChanged如何刷新界面？&lt;/li&gt;
&lt;li&gt;什么场景需要使用notifyDataSetChanged？什么场景需要使用局部更新？&lt;/li&gt;
&lt;li&gt;局部更新如何实现？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回到代码中，notifyDataSetChanged是在BaseAdapter中定义的，首先初始了一个DataSetObservable类的final实例mDataSetObservable：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private final DataSetObservable mDataSetObservable = new DataSetObservable();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;notifyDataSetChanged就是通过操作mDataSetObservable实现的，DataSetObservable是观察者模式的一个实现（Android源码中有很多类似设计模式的实现）。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void registerDataSetObserver(DataSetObserver observer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mDataSetObservable.registerObserver(observer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void unregisterDataSetObserver(DataSetObserver observer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mDataSetObservable.unregisterObserver(observer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void notifyDataSetChanged() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mDataSetObservable.notifyChanged();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void notifyDataSetInvalidated() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mDataSetObservable.notifyInvalidated();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;notifyDataSetChanged调用了notifyChanged方法，回到DataSetObservable中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void notifyChanged() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    synchronized(mObservers) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // since onChanged() is implemented by the app, it could do anything, including&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // removing itself from &amp;#123;@link mObservers&amp;#125; - and that could cause problems if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // an iterator is used on the ArrayList &amp;#123;@link mObservers&amp;#125;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // to avoid such problems, just march thru the list in the reverse order.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = mObservers.size() - 1; i &amp;gt;= 0; i--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mObservers.get(i).onChanged();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void notifyInvalidated() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    synchronized (mObservers) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = mObservers.size() - 1; i &amp;gt;= 0; i--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mObservers.get(i).onInvalidated();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;notifyChanged也只是调用了其绑定的接口，并没有具体的实现，那么这个接口是什么时候绑定的呢？回忆ListView与adapter的关联是何时开始的呢？setAdapter！是的，从setAdapter的代码中可以看到这种关联。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void setAdapter(ListAdapter adapter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mAdapter != null &amp;amp;&amp;amp; mDataSetObserver != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAdapter.unregisterDataSetObserver(mDataSetObserver);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resetList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mRecycler.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mHeaderViewInfos.size() &amp;gt; 0|| mFooterViewInfos.size() &amp;gt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAdapter = adapter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mOldSelectedPosition = INVALID_POSITION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mOldSelectedRowId = INVALID_ROW_ID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // AbsListView#setAdapter will update choice mode states.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.setAdapter(adapter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mAdapter != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mOldItemCount = mItemCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mItemCount = mAdapter.getCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        checkFocus();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 原来是在这里绑定了数据改变的观察者对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mDataSetObserver = new AdapterDataSetObserver();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAdapter.registerDataSetObserver(mDataSetObserver);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int position;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (mStackFromBottom) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            position = lookForSelectablePosition(mItemCount - 1, false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            position = lookForSelectablePosition(0, true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setSelectedPositionInt(position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setNextSelectedPositionInt(position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (mItemCount == 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Nothing selected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            checkSelectionChanged();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAreAllItemsSelectable = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        checkFocus();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Nothing selected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        checkSelectionChanged();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    requestLayout();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;前面提到，观察者对象调用的onChanged方法，可以确定，上述绑定的AdapterDataSetObserver中必然有onChanged方法的实现。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void onChanged() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mDataChanged = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mOldItemCount = mItemCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mItemCount = getAdapter().getCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ((getAdapter().hasStableIds()) &amp;amp;&amp;amp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (mInstanceState != null) &amp;amp;&amp;amp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (mOldItemCount == 0) &amp;amp;&amp;amp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (mItemCount &amp;gt; 0)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        onRestoreInstanceState(mInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mInstanceState = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rememberSyncState();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    checkFocus();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    requestLayout();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;很明显，在onChanged的末尾调用了requestLayout方法，而requestLayout方法是用来绘制界面的，定义在View中。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void requestLayout() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mMeasureCache != null) mMeasureCache.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mAttachInfo != null &amp;amp;&amp;amp; mAttachInfo.mViewRequestingLayout == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Only trigger request-during-layout logic if this is the view requesting it,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // not the views in its parent hierarchy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ViewRootImpl viewRoot = getViewRootImpl();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (viewRoot != null &amp;amp;&amp;amp; viewRoot.isInLayout()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (!viewRoot.requestLayoutDuringLayout(this)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAttachInfo.mViewRequestingLayout = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mPrivateFlags |= PFLAG_FORCE_LAYOUT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mPrivateFlags |= PFLAG_INVALIDATED;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mParent != null &amp;amp;&amp;amp; !mParent.isLayoutRequested()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mParent.requestLayout();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mAttachInfo != null &amp;amp;&amp;amp; mAttachInfo.mViewRequestingLayout == this) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAttachInfo.mViewRequestingLayout = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;根据上述解释，会发现notifyDataSetChanged会通知View刷新所有与其绑定的数据列表，而某些局部操作明显不需要全部刷新，全局刷新会造成极大的资源浪费。在这种情况下，就需要进行局部更新。&lt;/p&gt;
&lt;p&gt;局部更新的实现定义在是适配器（adapter）中，根据指定的index（即item在listview中的位置），实现指定条目内容的更新：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/** &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 局部刷新&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param index item在listview中的位置 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void updateItem(int index) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (listView == null) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 停止滑动时才更新界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 指定更新的位置在可见范围之内&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (index &amp;gt;= listView.getFirstVisiblePosition() &amp;amp;&amp;amp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            index &amp;lt;= listView.getLastVisiblePosition()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 获取当前可以看到的item位置  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int visiblePosition = listView.getFirstVisiblePosition();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            View view = listView.getChildAt(index - visiblePosition); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //在这里对view中的组件进行设置，数据可以通过getItem(index)获取//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（一个小问题：ListView的getCount()与getChildCount()有什么差别呢？）&lt;/p&gt;
&lt;p&gt;使用notifyDataSetChanged时，一个常见的问题就是调用了notifyDataSetChanged，但界面并没有刷新。很常见的原因是list的指向改变了，换句话说，list指向了与初始化时不同的堆地址。这种情况比较常见，给一个说明的链接：&lt;a href=&quot;http://www.tuicool.com/articles/aiiYzeR。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/aiiYzeR。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般的经验是在声明变量时对list进行初始化，当涉及数据改变时，通过add或者remove实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. listview的item内部组件的事件响应&lt;/strong&gt;&lt;br&gt;在具体的工程中，item组件的响应会根据对其使用的Activity（Fragment）的不同而变化，因此，不宜在其内部设定响应事件的具体实现。推荐在adapter中定义接口，将接口暴露给具体的Activity（Fragment），Activity（Fragment）根据具体的业务逻辑进行配置。以前面提到的论坛帖子为例，其包含以下操作：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 处理Item中控件的点击事件接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface ITopicItemOperation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void topicItemEdit(BBSTopicItem item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void topicItemCollect(BBSTopicItem item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void topicItemReply(BBSTopicItem item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后， 在Activity（Fragment）中实现上述接口：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 编辑主题贴&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void topicItemEdit(BBSTopicItem item) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 业务逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 收藏主题贴&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void topicItemCollect(BBSTopicItem item) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 业务逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 回复主题帖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void topicItemReply(BBSTopicItem item) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 业务逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将该实现通过adapter的构造器进行传递，以响应点击事件为例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 处理ListView中控件的点击事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private class TopicItemOnClickListener implements OnClickListener &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private BBSTopicItem item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public TopicItemOnClickListener(BBSTopicItem item) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.item = item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void onClick(View v) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        switch (v.getId()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case R.id.bbs_topic_edit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            topicItemOperation.topicItemEdit(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case R.id.bbs_topic_collect:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            topicItemOperation.topicItemCollect(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case R.id.bbs_topic_reply:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            topicItemOperation.topicItemReply(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在点击按钮时，添加TopicItemOnClickListener对象，即可实现不同的Activity（Fragment）对该项功能的复用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.图文混合显示&lt;/strong&gt;&lt;br&gt;在涉及论坛帖子的时候，图文混合显示一种很常见的场景。Android中没有原生支持图文混合显示的控件，github上有一些自定义控件能实现这种需求，百度一下也能发现很多。但此类个性化的需求需要很据项目实际来灵活运用，这里描述一种通过正则来处理的方法。比如，服务端返回的帖子内容如下：&lt;/p&gt;
&lt;p&gt;“全新宝马7系上市了，是不是很有气势？ &lt;a href=&quot;http://img2.tuohuangzu.com/THZ/UserBlog/0/15/2015061810510550085.jpg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://img2.tuohuangzu.com/THZ/UserBlog/0/15/2015061810510550085.jpg&lt;/a&gt; 不过相比于7系，我还是更喜欢3系的操控，转向非常精确，而且过弯姿势的建立也是非常恰到好处，过弯姿势建立的过早过晚都不好。过早会导致操控措手不及，无法感觉方向打多少，在匝道，有时打多了要在回，回多了又要打。过晚会导致路感缺失，侧倾明显，虚的慌 &lt;a href=&quot;http://res3.auto.ifeng.com/s/6606/0/3/13309355849880_3.jpghttp://img1.cheshi-img.com/product/1_1024/887/4b25a8df6e8ec.jpg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://res3.auto.ifeng.com/s/6606/0/3/13309355849880_3.jpghttp://img1.cheshi-img.com/product/1_1024/887/4b25a8df6e8ec.jpg&lt;/a&gt; 明天天气不错，去自驾游如何？”&lt;/p&gt;
&lt;p&gt;帖子内容为纯文本格式，显示时需要从中提取出图片的链接。这时正则就派上用场了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Pattern p = Pattern.compile(&amp;quot;http://[^\\u4e00-\\u9fa5]*?[.]jpg&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Matcher m = p.matcher(text);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int lastTextIndex = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (m.find()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 设置文本显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String textFrag = text.substring(lastTextIndex, m.start());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!textFrag.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        layout.addView(getTextView(context, textFrag));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 更新最后文本下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lastTextIndex = m.end();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 设置图片显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String imageUrl = m.group();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ImageView imageView = getImageView(context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setImageViewDisplay(imageView, imageUrl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layout.addView(imageView);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (lastTextIndex &amp;lt; text.length()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String textFrag = text.substring(lastTextIndex, text.length());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layout.addView(getTextView(context, textFrag));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码比较简单，只有一处需要说明。在上述帖子内容汇总，后面两张图片的链接是连续的，当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。因此，在上述场景中，想要将连续的两个URL匹配成功，则需要进行懒惰匹配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.ScrollView与ListView的冲突&lt;/strong&gt;&lt;br&gt;如果在ScrollView中嵌套了ListView（原则上应尽量避免这种情况），那么很不幸，可能会遇到以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ListView只显示一行&lt;/li&gt;
&lt;li&gt;页面默认不从顶端开始显示&lt;/li&gt;
&lt;li&gt;ListView滑动事件无法监听&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几个问题都是比较常见的问题了，这里不再赘述其原理，给出比较通用的解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;listview需要手动设置高度，这里给出一个链接：&lt;a href=&quot;http://www.cnblogs.com/zhwl/p/3333585.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/zhwl/p/3333585.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;listview需要设置listview.setFocusable(false);&lt;/li&gt;
&lt;li&gt;重载listview的onInterceptTouchEvent方法，在ACTION_DOWN时通过ScrollView的requestDisallowInterceptTouchEvent方法设置交出ontouch权限，ACTION_CANCEL时再恢复ontouch权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次强调，应尽量&lt;strong&gt;避免ScrollView中嵌套了ListView&lt;/strong&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ListView是Android开发中最常用的组件之一。本文将重点说明如何正确使用ListView，以及使用过程中可能遇到的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ListView开发模块&lt;/li&gt;
&lt;li&gt;图片缓存&lt;/li&gt;
&lt;li&gt;可能遇到的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;hr
    
    </summary>
    
      <category term="日志" scheme="http://yhthu.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ListView" scheme="http://yhthu.com/tags/ListView/"/>
    
      <category term="notifyDataSetChanged" scheme="http://yhthu.com/tags/notifyDataSetChanged/"/>
    
      <category term="图片缓存" scheme="http://yhthu.com/tags/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
