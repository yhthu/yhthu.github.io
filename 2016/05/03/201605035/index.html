<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计 | 杨浩的个人博客【yhthu.com】</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</h1><a id="logo" href="/.">杨浩的个人博客【yhthu.com】</a><p class="description">分享交流Android、CV、ML、NN等方面的技术和设计思想</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于yhthu</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</h1><div class="post-meta">May 3, 2016<span> | </span><span class="category"><a href="/categories/Android开发笔记/">Android开发笔记</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/05/03/201605035/" href="/2016/05/03/201605035/#comments" class="ds-thread-count"></a><div class="post-content"><p>Volley是由Google开源的、用于Android平台上的网络通信库。Volley通过优化Android的网络请求流程，形成了以<strong>Request-RequestQueue-Response</strong>为主线的网络访问链，使得Android网络访问变得<strong>简单、高效、扩展性强</strong>。（根据RTFSC原则，强烈建议Android的童鞋学习下Volley的架构设计）下面将以ImageLoader、ImageCache、ImageRequest及NetworkImageView为例，对此进行说明。</p>
<h2 id="一、ImageCache-ImageLoader-ImageListener"><a href="#一、ImageCache-ImageLoader-ImageListener" class="headerlink" title="一、ImageCache-ImageLoader-ImageListener"></a>一、ImageCache-ImageLoader-ImageListener</h2><p>对于图片的下载，这里采用自底向上的分析方法，即首先明确Volley加载图片是通过ImageLoader的get方法实现的，然后依次说明该方法需要的参数的构成。get方法有三种重载形式（早一些的版本没有第三种）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ImageContainer get(String requestUrl, final ImageListener listener);</span><br><span class="line">public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight);</span><br><span class="line">public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight, ScaleType scaleType);</span><br></pre></td></tr></table></figure></p>
<p> 不过前两种都是通过三种方法实现的，这里以第三种方法为例进行说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public ImageContainer get(String requestUrl, ImageListener imageListener,</span><br><span class="line">        int maxWidth, int maxHeight, ScaleType scaleType) &#123;</span><br><span class="line"></span><br><span class="line">    // only fulfill requests that were initiated from the main thread.</span><br><span class="line">    throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">    final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</span><br><span class="line"></span><br><span class="line">    // Try to look up the request in the cache of remote images.</span><br><span class="line">    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</span><br><span class="line">    if (cachedBitmap != null) &#123;</span><br><span class="line">        // Return the cached bitmap.</span><br><span class="line">        ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);</span><br><span class="line">        imageListener.onResponse(container, true);</span><br><span class="line">        return container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The bitmap did not exist in the cache, fetch it!</span><br><span class="line">    ImageContainer imageContainer =</span><br><span class="line">            new ImageContainer(null, requestUrl, cacheKey, imageListener);</span><br><span class="line"></span><br><span class="line">    // Update the caller to let them know that they should use the default bitmap.</span><br><span class="line">    imageListener.onResponse(imageContainer, true);</span><br><span class="line"></span><br><span class="line">    // Check to see if a request is already in-flight.</span><br><span class="line">    BatchedImageRequest request = mInFlightRequests.get(cacheKey);</span><br><span class="line">    if (request != null) &#123;</span><br><span class="line">        // If it is, add this request to the list of listeners.</span><br><span class="line">        request.addContainer(imageContainer);</span><br><span class="line">        return imageContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The request is not already in flight. Send the new request to the network and</span><br><span class="line">    // track it.</span><br><span class="line">    Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,</span><br><span class="line">            cacheKey);</span><br><span class="line"></span><br><span class="line">    mRequestQueue.add(newRequest);</span><br><span class="line">    mInFlightRequests.put(cacheKey,</span><br><span class="line">            new BatchedImageRequest(newRequest, imageContainer));</span><br><span class="line">    return imageContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码的逻辑非常清晰，可以下面的流程图来表示，不再赘述：<br><img src="/img/20151212-1.png" alt=""></p>
<blockquote>
<p>对于StringRequest、JsonRequest，Volley也采用了同样的处理流程。</p>
</blockquote>
<p>从get方法的形参入手，这里着重说明ImageListener（其它的形参见名知义）。ImageListener是ImageLoader的内部接口，继承于ErrorListener，需要实现的方法为onResponse：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface ImageListener extends ErrorListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Listens for non-error changes to the loading of the image request.</span><br><span class="line">     *</span><br><span class="line">     * @param response Holds all information pertaining to the request, as well</span><br><span class="line">     * as the bitmap (if it is loaded).</span><br><span class="line">     * @param isImmediate True if this was called during ImageLoader.get() variants.</span><br><span class="line">     * This can be used to differentiate between a cached image loading and a network</span><br><span class="line">     * image loading in order to, for example, run an animation to fade in network loaded</span><br><span class="line">     * images.</span><br><span class="line">     */</span><br><span class="line">    public void onResponse(ImageContainer response, boolean isImmediate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ImageLoader还提供了静态方法getImageListener来获取ImageListener实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static ImageListener getImageListener(final ImageView view,</span><br><span class="line">        final int defaultImageResId, final int errorImageResId) &#123;</span><br><span class="line">    return new ImageListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">            if (errorImageResId != 0) &#123;</span><br><span class="line">                view.setImageResource(errorImageResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onResponse(ImageContainer response, boolean isImmediate) &#123;</span><br><span class="line">            if (response.getBitmap() != null) &#123;</span><br><span class="line">                view.setImageBitmap(response.getBitmap());</span><br><span class="line">            &#125; else if (defaultImageResId != 0) &#123;</span><br><span class="line">                view.setImageResource(defaultImageResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码很容易看出，ImageListener就是Image请求返回时的回调接口，onErrorResponse和onResponse分别实现了请求失败和成功时加载对应的图片。<br>分析完get方法执行的流程及形参之后，我们回到ImageLoader本身。ImageLoader的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a new ImageLoader.</span><br><span class="line"> * @param queue The RequestQueue to use for making image requests.</span><br><span class="line"> * @param imageCache The cache to use as an L1 cache.</span><br><span class="line"> */</span><br><span class="line">public ImageLoader(RequestQueue queue, ImageCache imageCache) &#123;</span><br><span class="line">    mRequestQueue = queue;</span><br><span class="line">    mCache = imageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，从ImageLoader的形参入手，这里需要传入RequestQueue和ImageCache的实例对象。RequestQueue即整个Volley的核心请求队列，在使用Volley时第一个初始化的对象。其构造方法在Volley源码toolbox文件夹下的Volley工具类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Volley &#123;</span><br><span class="line"></span><br><span class="line">    /** Default on-disk cache directory. */</span><br><span class="line">    private static final String DEFAULT_CACHE_DIR = &quot;volley&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</span><br><span class="line">     *</span><br><span class="line">     * @param context A &#123;@link Context&#125; to use for creating the cache dir.</span><br><span class="line">     * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default.</span><br><span class="line">     * @return A started &#123;@link RequestQueue&#125; instance.</span><br><span class="line">     */</span><br><span class="line">    public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123;</span><br><span class="line">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line"></span><br><span class="line">        String userAgent = &quot;volley/0&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</span><br><span class="line">            userAgent = packageName + &quot;/&quot; + info.versionCode;</span><br><span class="line">        &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (stack == null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class="line">                stack = new HurlStack();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Prior to Gingerbread, HttpUrlConnection was unreliable.</span><br><span class="line">                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span><br><span class="line">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Network network = new BasicNetwork(stack);</span><br><span class="line"></span><br><span class="line">        RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line"></span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</span><br><span class="line">     *</span><br><span class="line">     * @param context A &#123;@link Context&#125; to use for creating the cache dir.</span><br><span class="line">     * @return A started &#123;@link RequestQueue&#125; instance.</span><br><span class="line">     */</span><br><span class="line">    public static RequestQueue newRequestQueue(Context context) &#123;</span><br><span class="line">        return newRequestQueue(context, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里重点说明ImageCache，即图片的缓存。ImageCache同样是定义在ImageLoader中的接口（从这里也可以看出volley的高可扩展性）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Simple cache adapter interface. If provided to the ImageLoader, it</span><br><span class="line"> * will be used as an L1 cache before dispatch to Volley. Implementations</span><br><span class="line"> * must not block. Implementation with an LruCache is recommended.</span><br><span class="line"> */</span><br><span class="line">public interface ImageCache &#123;</span><br><span class="line">    public Bitmap getBitmap(String url);</span><br><span class="line">    public void putBitmap(String url, Bitmap bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据注释可以看出，推荐使用LruCache。对于LruCache，前面的博文《Android开发笔记——ListView模块、缓存及性能》已做过详细介绍，其通过维护一个强引用来限制内容数量，每当Item被访问的时候，此Item就会移动到队列的头部。当cache已满时加入新的item，在队列尾部的item会被回收。<br>不过，在某些应用场景下，只使用LruCache还不够。当应用退出后，LruCache清空，重新加载时，缓存的图片依然需要重新加载。这里需要使用DiskLruCache，即磁盘缓存，原理与《Android开发笔记——ListView模块、缓存及性能》中SD卡存储配合LruCache相同，但DiskLruCache实现更为合理，获得Google官方认证。</p>
<blockquote>
<p>对于DiskLruCache的源码解析，推荐Android DiskLruCache完全解析，硬盘缓存的最佳方案。</p>
</blockquote>
<p>因此，建议配合LruCache和DiskLruCache，以及Volley的请求缓存，形成图片三级缓存。LruCache和DiskLruCache的初始化方法分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxSize = (int) (Runtime.getRuntime().maxMemory() / 8);</span><br><span class="line">// 实例化LruCaceh对象</span><br><span class="line">mLruCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;</span><br><span class="line">     @Override</span><br><span class="line">     protected int sizeOf(String key, Bitmap bitmap) &#123;</span><br><span class="line">          return bitmap.getRowBytes() * bitmap.getHeight();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 实例化DiskLruCache对象</span><br><span class="line"> try &#123;</span><br><span class="line">      // 获取DiskLruCahce对象</span><br><span class="line">      mDiskLruCache = DiskLruCache.open(getDiskCacheDir(</span><br><span class="line">                    context.getApplicationContext(), &quot;younghao&quot;), getAppVersion(context), 1, DISKMAXSIZE);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ImageCaches实现getBitmap和putBitmap方法时，可以使用LruCache和DiskLruCache实例高效处理图片。存入缓存时，先存入到LruCache中，然后判断是否存在DiskLruCache缓存，若没有存入；读取图片时，先从LruCache中取，没有时再从DiskLruCache中取（取出之后，顺便存入LruCache中，供下次访问时使用，不再访问DiskLruCache）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 存入缓存（内存缓存，磁盘缓存）</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void putBitmap(String url, Bitmap bitmap) &#123;</span><br><span class="line">    // 存入LruCache缓存</span><br><span class="line">    mLruCache.put(url, bitmap);</span><br><span class="line">    // 判断是否存在DiskLruCache缓存，若没有存入</span><br><span class="line">    String key = MD5Utils.md5(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (mDiskLruCache.get(key) == null) &#123;</span><br><span class="line">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);</span><br><span class="line">            if (editor != null) &#123;</span><br><span class="line">                OutputStream outputStream = editor.newOutputStream(0);</span><br><span class="line">                if (bitmap.compress(CompressFormat.JPEG, 100, outputStream)) &#123;</span><br><span class="line">                    editor.commit();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    editor.abort();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mDiskLruCache.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从缓存（内存缓存，磁盘缓存）中获取Bitmap</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Bitmap getBitmap(String url) &#123;</span><br><span class="line">    if (mLruCache.get(url) != null) &#123;</span><br><span class="line">        // 从LruCache缓存中取</span><br><span class="line">        Log.i(TAG, &quot;从LruCahce获取&quot;);</span><br><span class="line">        return mLruCache.get(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String key = MD5Utils.md5(url);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (mDiskLruCache.get(key) != null) &#123;</span><br><span class="line">                // 从DiskLruCahce取</span><br><span class="line">                DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);</span><br><span class="line">                Bitmap bitmap = null;</span><br><span class="line">                if (snapshot != null) &#123;</span><br><span class="line">                    bitmap = BitmapFactory.decodeStream(snapshot.getInputStream(0));</span><br><span class="line">                    // 存入LruCache缓存</span><br><span class="line">                    mLruCache.put(url, bitmap);</span><br><span class="line">                    Log.i(TAG, &quot;从DiskLruCahce获取&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return bitmap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，通过volley加载图片的方法已完成。调用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取ImageCache实例</span><br><span class="line">ImageCacheUtil imageCacheUtil = ImageCacheUtil.instance(context);</span><br><span class="line">// 初始化ImageLoader实例</span><br><span class="line">ImageLoader imageLoader = new ImageLoader(requestQueue, imageCacheUtil);</span><br><span class="line">// 获取ImageListener实例</span><br><span class="line">ImageListener listener = ImageLoader.getImageListener(imageRequestBean.getImageView(),</span><br><span class="line">        imageRequestBean.getDefaultImageID(), imageRequestBean.getErrorImageID());</span><br><span class="line">// 发送请求图片</span><br><span class="line">imageLoader.get(imageRequestBean.getUrl(),                 listener,imageRequestBean.getMaxWidth(), imageRequestBean.getMaxHeight());</span><br></pre></td></tr></table></figure></p>
<h2 id="二、对Volley的架构的理解"><a href="#二、对Volley的架构的理解" class="headerlink" title="二、对Volley的架构的理解"></a>二、对Volley的架构的理解</h2><p>如果有童鞋能读到这里，那么对Volley的网络请求处理逻辑应该已经有了一定的认识。下面将通过Volley的官方文档对Volley的架构作进一步的说明。Volley提供了对于网络请求的自动调度，能够处理高并发网络链接，拥有透明的磁盘及内存缓存，支持请求优先级、取消请求、异步网络请求等。Volley的源码地址为：<a href="https://android.googlesource.com/platform/frameworks/volley（git" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley（git</a> clone），不过考虑到网络问题，也可到github上下载：<a href="https://github.com/mcxiaoke/android-volley.git（git" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley.git（git</a> clone）。</p>
<blockquote>
<p>2013年Volley发布会视频：Google I/O 2013 - Volley: Easy, Fast Networking for Android（YouTube，你懂）</p>
</blockquote>
<h3 id="2-1-发送一个简单的请求"><a href="#2-1-发送一个简单的请求" class="headerlink" title="2.1 发送一个简单的请求"></a>2.1 发送一个简单的请求</h3><p>先贴一张官网的图，后面做解释。<br><img src="/img/20151212-2.png" alt=""><br>这张图展示了Volley的核心架构，主要包含了以下类：</p>
<ul>
<li>Volley。前面已经提到，位于toolbox文件中，是创建请求队列的工具类；</li>
<li>Request。实现了Comparable<request<t>&gt;接口的抽象类，Volley中的请求都是继承于该类实现的，Request支持八种请求方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure>
</request<t></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Supported request methods.</span><br><span class="line"> */</span><br><span class="line">public interface Method &#123;</span><br><span class="line">    int DEPRECATED_GET_OR_POST = -1;</span><br><span class="line">    int GET = 0;</span><br><span class="line">    int POST = 1;</span><br><span class="line">    int PUT = 2;</span><br><span class="line">    int DELETE = 3;</span><br><span class="line">    int HEAD = 4;</span><br><span class="line">    int OPTIONS = 5;</span><br><span class="line">    int TRACE = 6;</span><br><span class="line">    int PATCH = 7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RequestQueue。Volley的核心，代表整个请求队列。需要重点说明的是其成员变量，包含了<ul>
<li>CacheDispatcher（处理缓存请求的调度线程）</li>
<li>NetworkDispatcher[]（处理网络请求的调用线程组）</li>
<li>ResponseDelivery（网络请求返回接口分发）</li>
<li>Network （执行网络请求的网络接口）</li>
<li>Cache（缓存请求的接口，PS：上一节说的是缓存图片）</li>
<li>DEFAULT_NETWORK_THREAD_POOL_SIZE（默认线程池数目，至于为什么是4？这是一个经验值，在自己实际应用中，可根据任务、网络状况以及设备等灵活设置）</li>
<li>PriorityBlockingQueue<request<?>&gt; （基于优先级阻塞的请求队列，包含等待的和正在执行的）、</request<?></li>
<li>Set<request<?>&gt; mCurrentRequests （正在处理的请求）</request<?></li>
<li>Map<string, queue<request<?="">&gt;&gt; mWaitingRequests（正在等待的请求）</string,></li>
<li>AtomicInteger mSequenceGenerator（原子的，避免并发访问）</li>
<li>RequestFinishedListener<t>接口（请求完成的回调）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/** Callback interface for completed requests. */</span><br><span class="line">public static interface RequestFinishedListener&lt;T&gt; &#123;</span><br><span class="line">    /** Called when a request has finished processing. */</span><br><span class="line">    public void onRequestFinished(Request&lt;T&gt; request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Used for generating monotonically-increasing sequence numbers for requests. */</span><br><span class="line">private AtomicInteger mSequenceGenerator = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Staging area for requests that already have a duplicate request in flight.</span><br><span class="line"> *</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</span><br><span class="line"> *          key.&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</span><br><span class="line"> *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span><br><span class="line">private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line">        new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The set of all requests currently being processed by this RequestQueue. A Request</span><br><span class="line"> * will be in this set if it is waiting in any queue or currently being processed by</span><br><span class="line"> * any dispatcher.</span><br><span class="line"> */</span><br><span class="line">private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">/** The cache triage queue. */</span><br><span class="line">private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</span><br><span class="line">    new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">/** The queue of requests that are actually going out to the network. */</span><br><span class="line">private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line">    new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">/** Number of network request dispatcher threads to start. */</span><br><span class="line">private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;</span><br><span class="line"></span><br><span class="line">/** Cache interface for retrieving and storing responses. */</span><br><span class="line">private final Cache mCache;</span><br><span class="line"></span><br><span class="line">/** Network interface for performing requests. */</span><br><span class="line">private final Network mNetwork;</span><br><span class="line"></span><br><span class="line">/** Response delivery mechanism. */</span><br><span class="line">private final ResponseDelivery mDelivery;</span><br><span class="line"></span><br><span class="line">/** The network dispatchers. */</span><br><span class="line">private NetworkDispatcher[] mDispatchers;</span><br><span class="line"></span><br><span class="line">/** The cache dispatcher. */</span><br><span class="line">private CacheDispatcher mCacheDispatcher;</span><br><span class="line"></span><br><span class="line">private List&lt;RequestFinishedListener&gt; mFinishedListeners =</span><br><span class="line">        new ArrayList&lt;RequestFinishedListener&gt;();</span><br></pre></td></tr></table></figure>
</t></li>
</ul>
</li>
</ul>
<p>发送一个请求，只需将请求添加到请求队列即可。官网的一段示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final TextView mTextView = (TextView) findViewById(R.id.text);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Instantiate the RequestQueue.</span><br><span class="line">RequestQueue queue = Volley.newRequestQueue(this);</span><br><span class="line">String url =&quot;http://www.google.com&quot;;</span><br><span class="line"></span><br><span class="line">// Request a string response from the provided URL.</span><br><span class="line">StringRequest stringRequest = new StringRequest(Request.Method.GET, url,</span><br><span class="line">            new Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(String response) &#123;</span><br><span class="line">        // Display the first 500 characters of the response string.</span><br><span class="line">        mTextView.setText(&quot;Response is: &quot;+ response.substring(0,500));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, new Response.ErrorListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">        mTextView.setText(&quot;That didn&apos;t work!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// Add the request to the RequestQueue.</span><br><span class="line">queue.add(stringRequest);</span><br></pre></td></tr></table></figure></p>
<p>取消请求同样简单，通过TAG来找到特定的request，然后取消。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static final String TAG = &quot;MyTag&quot;;</span><br><span class="line">StringRequest stringRequest; // Assume this exists.</span><br><span class="line">RequestQueue mRequestQueue;  // Assume this exists.</span><br><span class="line"></span><br><span class="line">// Set the tag on the request.</span><br><span class="line">stringRequest.setTag(TAG);</span><br><span class="line"></span><br><span class="line">// Add the request to the RequestQueue.</span><br><span class="line">mRequestQueue.add(stringRequest);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onStop () &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    if (mRequestQueue != null) &#123;</span><br><span class="line">        mRequestQueue.cancelAll(TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建一个RequestQueue"><a href="#2-2-创建一个RequestQueue" class="headerlink" title="2.2 创建一个RequestQueue"></a>2.2 创建一个RequestQueue</h3><p> 在2.1节中，使用了默认的RequestQueue构造器（即通过Volley工具类），但Volley支持自定义NetWork和Cache，实现更加个性化的网络和缓存。另外一个需要注意的问题就是单例模式，为了高效的使用RequestQueue，官方建议在整个应用的生命周期内只使用一个RequestQueue实例。<strong>不过注意到很多中文的帖子使用继承Application，在Application的onCreate()方法中创建RequestQueue，官方并不鼓励这种做法，使用静态的的单例能够以更加模块化的方式实现同样的功能。</strong>核心的思想是RequestQueue应该被Application的context实例，而不是某个Activity的context。（getApplicationContext()与getContext()方法的区别）</p>
<h3 id="2-3-创建一个标准的请求"><a href="#2-3-创建一个标准的请求" class="headerlink" title="2.3 创建一个标准的请求"></a>2.3 创建一个标准的请求</h3><p>继承Request的请求类型主要有：StringRequest、ImageRequest、JsonObjectRequest和JsonArrayRequest（JsonRequest的子类），第一节对ImageRequest进行了详细的说明，这里主要说明JsonObjectRequest和JsonArrayRequest，因为在实际项目中，通Json传递数据可能是目前最常见的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TextView mTxtDisplay;</span><br><span class="line">ImageView mImageView;</span><br><span class="line">mTxtDisplay = (TextView) findViewById(R.id.txtDisplay);</span><br><span class="line">String url = &quot;http://my-json-feed&quot;;</span><br><span class="line"></span><br><span class="line">JsonObjectRequest jsObjRequest = new JsonObjectRequest</span><br><span class="line">        (Request.Method.GET, url, null, new Response.Listener&lt;JSONObject&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(JSONObject response) &#123;</span><br><span class="line">        mTxtDisplay.setText(&quot;Response: &quot; + response.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, new Response.ErrorListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Access the RequestQueue through your singleton class.</span><br><span class="line">MySingleton.getInstance(this).addToRequestQueue(jsObjRequest);</span><br></pre></td></tr></table></figure></p>
<p> 官方的示例代码比较简单。不过可以关注下Request的方法，它抽象了StringRequest、ImageRequest、JsonRequest的公共特征，这种结构设计的思路值得学习。</p>
<p>最后推荐几个博客作为参考：<br><a href="http://p.codekk.com/blogs/detail/54cfab086c4761e5001b2542" target="_blank" rel="external">Volley 源码解析</a><br><a href="https://bxbxbai.github.io/2014/09/14/android-working-with-volley/" target="_blank" rel="external">Android库Volley的使用介绍</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="external">Android Volley完全解析(四)，带你从源码的角度理解Volley（Volley系列文章）</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yhthu.com/2016/05/03/201605035/" data-id="cite9xz1r000b6crselkhqzep" class="article-share-link">分享到</a><div class="tags"><a href="/tags/图片缓存/">图片缓存</a><a href="/tags/Volley架构/">Volley架构</a></div><div class="post-nav"><a href="/2016/05/03/201605037/" class="pre">Android开发笔记——视频录制播放常见问题</a><a href="/2016/05/03/201605032/" class="next">Android线程管理（一）——线程通信</a></div><div data-thread-key="2016/05/03/201605035/" data-title="Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计" data-url="http://yhthu.com/2016/05/03/201605035/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/05/03/201605035/" data-title="Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计" data-url="http://yhthu.com/2016/05/03/201605035/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yhthu.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android内存管理/">Android内存管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发笔记/">Android开发笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android源码笔记/">Android源码笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android线程管理/">Android线程管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/notifyDataSetChanged/" style="font-size: 15px;">notifyDataSetChanged</a> <a href="/tags/Android-Camera/" style="font-size: 15px;">Android Camera</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/图片缓存/" style="font-size: 15px;">图片缓存</a> <a href="/tags/OOM分析/" style="font-size: 15px;">OOM分析</a> <a href="/tags/Volley架构/" style="font-size: 15px;">Volley架构</a> <a href="/tags/视频录制播放/" style="font-size: 15px;">视频录制播放</a> <a href="/tags/ListView/" style="font-size: 15px;">ListView</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/Android架构/" style="font-size: 15px;">Android架构</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/MVC/" style="font-size: 15px;">MVC</a> <a href="/tags/Android内存管理/" style="font-size: 15px;">Android内存管理</a> <a href="/tags/进程内存/" style="font-size: 15px;">进程内存</a> <a href="/tags/Theory-Algorithms-Implementation/" style="font-size: 15px;">Theory, Algorithms, Implementation</a> <a href="/tags/Perceiving-and-modeling-environment/" style="font-size: 15px;">Perceiving and modeling environment</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/201609221/">Android App的架构设计：从VM、MVC、MVP到MVVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/201605161/">Android开发笔记——内存泄露与线程安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/201605201/">读书笔记-Autonomous Intelligent Vehicles（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605031/">Android源码笔记——Camera系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605034/">Android线程管理（三）——Thread类的内部原理、休眠及唤醒</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605033/">Android线程管理（二）——ActivityThread</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605038/">Android开发笔记——ListView模块、缓存及性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605037/">Android开发笔记——视频录制播放常见问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605035/">Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605032/">Android线程管理（一）——线程通信</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://androidweekly.cn/" title="Android开发技术周报" target="_blank">Android开发技术周报</a><ul></ul><a href="http://p.codekk.com/" title="codeKK开源项目源码解析" target="_blank">codeKK开源项目源码解析</a><ul></ul><a href="http://www.trinea.cn/" title="Trinea技术博客" target="_blank">Trinea技术博客</a><ul></ul><a href="http://hukai.me/" title="胡凯技术博客" target="_blank">胡凯技术博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">杨浩的个人博客【yhthu.com】.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'yhthu'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>