<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android源码笔记——Camera系统架构 | 道阻且长【yhthu.com】</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android源码笔记——Camera系统架构</h1><a id="logo" href="/.">道阻且长【yhthu.com】</a><p class="description">分享交流Android、CV、ML、NN等方面的技术和设计思想</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于yhthu</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android源码笔记——Camera系统架构</h1><div class="post-meta">May 3, 2016<span> | </span><span class="category"><a href="/categories/Android源码笔记/">Android源码笔记</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/05/03/Android源码笔记——Camera系统架构/" href="/2016/05/03/Android源码笔记——Camera系统架构/#comments" class="ds-thread-count"></a><div class="post-content"><p>Camera的架构与Android系统的整体架构保持一致，如下图所示，本文主要从以下四个方面对其进行说明。</p>
<ol>
<li>Framework：Camera.java</li>
<li>Android Runtime：android_hardware_Camera.cpp</li>
<li>Library：Camera Client和Camera Service</li>
<li>HAL：CameraHardwareInterface</li>
</ol>
<p><img src="/img/20160401-1.png" alt=""></p>
<hr>
<h2 id="一、Framework：Camera-java"><a href="#一、Framework：Camera-java" class="headerlink" title="一、Framework：Camera.java"></a>一、Framework：Camera.java</h2><p>Camera是应用层软件直接使用的类，涵盖了启动、预览、拍摄及关闭等操作摄像头的全部接口。Camera.java在Android源码中的路径为：framework/base/core/java/android/hardware。为了说明整个Camera系统的架构，这里暂不横向分析Camera.java的功能，下面从open()方法着手：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static Camera open() &#123;</span><br><span class="line">    int numberOfCameras = getNumberOfCameras();</span><br><span class="line">    CameraInfo cameraInfo = new CameraInfo();</span><br><span class="line">    for (int i = 0; i &lt; numberOfCameras; i++) &#123;</span><br><span class="line">        getCameraInfo(i, cameraInfo);</span><br><span class="line">        if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            return new Camera(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open()方法需要注意以下几点：</p>
<ul>
<li>getNumberOfCameras为native方法，实现在android_hardware_Camera.cpp中；</li>
<li>CameraInfo是Camera定义的静态内部类，包含facing、orientation、canDisableShutterSound；</li>
<li>getCameraInfo内部调用native方法_getCameraInfo获取摄像头信息；</li>
<li>open()默认启动的是后置摄像头（CAMERA_FACING_BACK）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/** used by Camera#open, Camera#open(int) */</span><br><span class="line">Camera(int cameraId) &#123;</span><br><span class="line">    int err = cameraInitNormal(cameraId);</span><br><span class="line">    if (checkInitErrors(err)) &#123;</span><br><span class="line">        switch(err) &#123;</span><br><span class="line">            case EACCESS:</span><br><span class="line">                throw new RuntimeException(&quot;Fail to connect to camera service&quot;);</span><br><span class="line">            case ENODEV:</span><br><span class="line">                throw new RuntimeException(&quot;Camera initialization failed&quot;);</span><br><span class="line">            default:</span><br><span class="line">                // Should never hit this.</span><br><span class="line">                throw new RuntimeException(&quot;Unknown camera error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Camera构造器的核心实现在cameraInitNormal中，cameraInitNormal调用cameraInitVersion，并传入参数cameraId和CAMERA_HAL_API_VERSION_NORMAL_CONNECT，后者代表HAL的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private int cameraInitVersion(int cameraId, int halVersion) &#123;</span><br><span class="line">    ……</span><br><span class="line">    String packageName = ActivityThread.currentPackageName();</span><br><span class="line">    return native_setup(new WeakReference&lt;Camera&gt;(this), cameraId, halVersion, packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cameraInitNormal调用本地方法native_setup()，由此进入到android_hardware_Camera.cpp中，native_setup()的签名如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private native final int native_setup(Object camera_this, </span><br><span class="line">                                int cameraId, int halVersion, String packageName);</span><br></pre></td></tr></table></figure></p>
<h2 id="二、Android-Runtime：android-hardware-Camera-cpp"><a href="#二、Android-Runtime：android-hardware-Camera-cpp" class="headerlink" title="二、Android Runtime：android_hardware_Camera.cpp"></a>二、Android Runtime：android_hardware_Camera.cpp</h2><p>native_setup()被动态注册到JNI，通过JNI调用android_hardware_Camera_native_setup()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod camMethods[] = &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#123; &quot;native_setup&quot;,    &quot;(Ljava/lang/Object;ILjava/lang/String;)V&quot;,</span><br><span class="line">    (void*)android_hardware_Camera_native_setup &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>JNI的重点是android_hardware_Camera_native_setup()方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// connect to camera service</span><br><span class="line">static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz,</span><br><span class="line">    jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName)</span><br><span class="line">&#123;</span><br><span class="line">    // Convert jstring to String16</span><br><span class="line">    const char16_t *rawClientName = env-&gt;GetStringChars(clientPackageName, NULL);</span><br><span class="line">    jsize rawClientNameLen = env-&gt;GetStringLength(clientPackageName);</span><br><span class="line">    String16 clientName(rawClientName, rawClientNameLen);</span><br><span class="line">    env-&gt;ReleaseStringChars(clientPackageName, rawClientName);</span><br><span class="line"></span><br><span class="line">    sp&lt;Camera&gt; camera;</span><br><span class="line">    if (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) &#123;</span><br><span class="line">        // Default path: hal version is don&apos;t care, do normal camera connect.</span><br><span class="line">        camera = Camera::connect(cameraId, clientName,</span><br><span class="line">                Camera::USE_CALLING_UID);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        jint status = Camera::connectLegacy(cameraId, halVersion, clientName,</span><br><span class="line">                Camera::USE_CALLING_UID, camera);</span><br><span class="line">        if (status != NO_ERROR) &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (camera == NULL) &#123;</span><br><span class="line">        return -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // make sure camera hardware is alive</span><br><span class="line">    if (camera-&gt;getStatus() != NO_ERROR) &#123;</span><br><span class="line">        return NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(thiz);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        // This should never happen</span><br><span class="line">        jniThrowRuntimeException(env, &quot;Can&apos;t find android/hardware/Camera&quot;);</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We use a weak reference so the Camera object can be garbage collected.</span><br><span class="line">    // The reference is only used as a proxy for callbacks.</span><br><span class="line">    sp&lt;JNICameraContext&gt; context = new JNICameraContext(env, weak_this, clazz, camera);</span><br><span class="line">    context-&gt;incStrong((void*)android_hardware_Camera_native_setup);</span><br><span class="line">    camera-&gt;setListener(context);</span><br><span class="line"></span><br><span class="line">    // save context in opaque field</span><br><span class="line">    env-&gt;SetLongField(thiz, fields.context, (jlong)context.get());</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>android_hardware_Camera_native_setup()方法通过调用Camera::connect()方法请求连接CameraService服务。入参中：</p>
<ul>
<li>clientName是通过将clientPackageName从jstring转换为String16格式得到；</li>
<li>Camera::USE_CALLING_UID是定义在Camera.h中的枚举类型，其值为ICameraService::USE_CALLING_UID（同样为枚举类型，值为-1）。</li>
</ul>
<p>Camera::connect()位于Camera.cpp中，由此进入到Library层。</p>
<h2 id="三、Library：Camera-Client和Camera-Service"><a href="#三、Library：Camera-Client和Camera-Service" class="headerlink" title="三、Library：Camera Client和Camera Service"></a>三、Library：Camera Client和Camera Service</h2><p>如上述架构图中所示，ICameraService.h、ICameraClient.h和ICamera.h三个类定义了Camera的接口和架构，ICameraService.cpp和Camera.cpp两个文件用于Camera架构的实现，Camera的具体功能在下层调用硬件相关的接口来实现。Camera.h是Camera系统对上层的接口。</p>
<p>具体的，Camera类继承模板类CameraBase，Camera::connect()调用了CameraBase.cpp中的connect()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Camera&gt; Camera::connect(int cameraId, const String16&amp; clientPackageName,</span><br><span class="line">        int clientUid) &#123;</span><br><span class="line">    return CameraBaseT::connect(cameraId, clientPackageName, clientUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CameraBase实际上又继承了IBinder的DeathRecipient内部类，DeathRecipient虚拟继承自RefBase。RefBase是Android中的引用计数基础类，其中定义了incStrong、decStrong、incWeak和decWeak等涉及sp/wp的指针操作函数，当然这扯远了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename TCam&gt;</span><br><span class="line">struct CameraTraits &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename TCam, typename TCamTraits = CameraTraits&lt;TCam&gt; &gt;</span><br><span class="line">class CameraBase : public IBinder::DeathRecipient</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    static sp&lt;TCam&gt; connect(int cameraId,</span><br><span class="line">                            const String16&amp; clientPackageName,</span><br><span class="line">                            int clientUid);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DeathRecipient : public virtual RefBase</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到Camera::connect()的实现上，其中，new TCam(cameraId)生成BnCameraClient对象，BnCameraClient定义在ICameraClient.h文件中，继承自模板类BnInterface。getCameraService()方法返回CameraService的服务代理BpCameraService，BpCameraService同样继承自模板类BnInterface。然后通过Binder通信发送CONNECT命令，当BnCameraService收到CONNECT命令后调用CameraService的connect()成员函数来做相应的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename TCam, typename TCamTraits&gt;</span><br><span class="line">sp&lt;TCam&gt; CameraBase&lt;TCam, TCamTraits&gt;::connect(int cameraId,</span><br><span class="line">                                               const String16&amp; clientPackageName,</span><br><span class="line">                                               int clientUid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;%s: connect&quot;, __FUNCTION__);</span><br><span class="line">    sp&lt;TCam&gt; c = new TCam(cameraId); // BnCameraClient </span><br><span class="line">    sp&lt;TCamCallbacks&gt; cl = c;</span><br><span class="line">    status_t status = NO_ERROR;</span><br><span class="line">    const sp&lt;ICameraService&gt;&amp; cs = getCameraService(); // BpCameraService</span><br><span class="line"></span><br><span class="line">    if (cs != 0) &#123;</span><br><span class="line">        TCamConnectService fnConnectService = TCamTraits::fnConnectService;</span><br><span class="line">        status = (cs.get()-&gt;*fnConnectService)(cl, cameraId, clientPackageName, clientUid,</span><br><span class="line">                                             /*out*/ c-&gt;mCamera);</span><br><span class="line">    &#125;</span><br><span class="line">    if (status == OK &amp;&amp; c-&gt;mCamera != 0) &#123;</span><br><span class="line">        c-&gt;mCamera-&gt;asBinder()-&gt;linkToDeath(c);</span><br><span class="line">        c-&gt;mStatus = NO_ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGW(&quot;An error occurred while connecting to camera: %d&quot;, cameraId);</span><br><span class="line">        c.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BnCameraClient: public BnInterface&lt;ICameraClient&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual status_t    onTransact( uint32_t code,</span><br><span class="line">                                    const Parcel&amp; data,</span><br><span class="line">                                    Parcel* reply,</span><br><span class="line">                                    uint32_t flags = 0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class BpCameraService: public BpInterface&lt;ICameraService&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BpCameraService(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;ICameraService&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：connect()函数在BpCameraService和BnCameraService的父类ICameraService中声明为纯虚函数，在BpCameraService和CameraService中分别给出了实现，BpCameraService作为代理类，提供接口给客户端，真正实现在BnCameraService的子类CameraService中。</p>
<p>在BpCameraService中，connect()函数实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// connect to camera service (android.hardware.Camera)</span><br><span class="line">virtual status_t connect(const sp&lt;ICameraClient&gt;&amp; cameraClient, int cameraId,</span><br><span class="line">                         const String16 &amp;clientPackageName, int clientUid,</span><br><span class="line">                         /*out*/</span><br><span class="line">                         sp&lt;ICamera&gt;&amp; device)</span><br><span class="line">&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ICameraService::getInterfaceDescriptor());</span><br><span class="line">    data.writeStrongBinder(cameraClient-&gt;asBinder());</span><br><span class="line">    data.writeInt32(cameraId);</span><br><span class="line">    data.writeString16(clientPackageName);</span><br><span class="line">    data.writeInt32(clientUid);</span><br><span class="line">    remote()-&gt;transact(BnCameraService::CONNECT, data, &amp;reply); // BpBinder的transact()函数向IPCThreadState实例发送消息，通知其有消息要发送给binder driver        </span><br><span class="line">    if (readExceptionCode(reply)) return -EPROTO;</span><br><span class="line">    status_t status = reply.readInt32();</span><br><span class="line">    if (reply.readInt32() != 0) &#123;</span><br><span class="line">        device = interface_cast&lt;ICamera&gt;(reply.readStrongBinder()); // client端读出server返回的bind</span><br><span class="line">    &#125;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先将传递过来的Camera对象cameraClient转换成IBinder类型，将调用的参数写到Parcel（可理解为Binder通信的管道）中，通过BpBinder的transact()函数发送消息，然后由BnCameraService去响应该连接，最后就是等待服务端返回，如果成功则生成一个BpCamera实例。</p>
<p>真正的服务端响应实现在BnCameraService的onTransact()函数中，其负责解包收到的Parcel并执行client端的请求的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">status_t BnCameraService::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">        ……</span><br><span class="line">     case CONNECT: &#123;</span><br><span class="line">            CHECK_INTERFACE(ICameraService, data, reply);</span><br><span class="line">            sp&lt;ICameraClient&gt; cameraClient =</span><br><span class="line">                    interface_cast&lt;ICameraClient&gt;(data.readStrongBinder()); // 使用Camera的Binder对象生成Camera客户代理BpCameraClient实例</span><br><span class="line">              int32_t cameraId = data.readInt32();</span><br><span class="line">            const String16 clientName = data.readString16();</span><br><span class="line">            int32_t clientUid = data.readInt32();</span><br><span class="line">            sp&lt;ICamera&gt; camera;</span><br><span class="line">            status_t status = connect(cameraClient, cameraId,</span><br><span class="line">                    clientName, clientUid, /*out*/camera); // 将生成的BpCameraClient对象作为参数传递到CameraService的connect()函数中</span><br><span class="line">              reply-&gt;writeNoException();</span><br><span class="line">            reply-&gt;writeInt32(status); // 将BpCamera对象以IBinder的形式打包到Parcel中返回</span><br><span class="line">              if (camera != NULL) &#123;</span><br><span class="line">                reply-&gt;writeInt32(1);</span><br><span class="line">                reply-&gt;writeStrongBinder(camera-&gt;asBinder());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply-&gt;writeInt32(0);</span><br><span class="line">            &#125;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的处理包括：</p>
<ol>
<li>通过data中Camera的Binder对象生成Camera客户代理BpCameraClient实例；</li>
<li>将生成的BpCameraClient对象作为参数传递到CameraService（/frameworks/av/services/camera /libcameraservice/CameraService.cpp）的connect()函数中，该函数会返回一个BpCamera实例；</li>
<li>将在上述实例对象以IBinder的形式打包到Parcel中返回。</li>
</ol>
<p>最后，BpCamera实例是通过CameraService::connect()函数返回的。CameraService::connect()实现的核心是调用connectHelperLocked()函数根据HAL不同API的版本创建不同的client实例（早期版本中好像没有connectHelperLocked()这个函数，但功能基本相似）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraService::connectHelperLocked(</span><br><span class="line">        /*out*/</span><br><span class="line">        sp&lt;Client&gt;&amp; client,</span><br><span class="line">        /*in*/</span><br><span class="line">        const sp&lt;ICameraClient&gt;&amp; cameraClient,</span><br><span class="line">        int cameraId,</span><br><span class="line">        const String16&amp; clientPackageName,</span><br><span class="line">        int clientUid,</span><br><span class="line">        int callingPid,</span><br><span class="line">        int halVersion,</span><br><span class="line">        bool legacyMode) &#123;</span><br><span class="line"></span><br><span class="line">    int facing = -1;</span><br><span class="line">    int deviceVersion = getDeviceVersion(cameraId, &amp;facing);</span><br><span class="line"></span><br><span class="line">    if (halVersion &lt; 0 || halVersion == deviceVersion) &#123;</span><br><span class="line">        // Default path: HAL version is unspecified by caller, create CameraClient</span><br><span class="line">        // based on device version reported by the HAL.</span><br><span class="line">        switch(deviceVersion) &#123;</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_1_0:</span><br><span class="line">            client = new CameraClient(this, cameraClient,</span><br><span class="line">                    clientPackageName, cameraId,</span><br><span class="line">                    facing, callingPid, clientUid, getpid(), legacyMode);</span><br><span class="line">            break;</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_2_0:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_2_1:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">          case CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">            client = new Camera2Client(this, cameraClient,</span><br><span class="line">                    clientPackageName, cameraId,</span><br><span class="line">                    facing, callingPid, clientUid, getpid(), legacyMode);</span><br><span class="line">            break;</span><br><span class="line">          case -1:</span><br><span class="line">            ALOGE(&quot;Invalid camera id %d&quot;, cameraId);</span><br><span class="line">            return BAD_VALUE;</span><br><span class="line">          default:</span><br><span class="line">            ALOGE(&quot;Unknown camera device HAL version: %d&quot;, deviceVersion);</span><br><span class="line">            return INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // A particular HAL version is requested by caller. Create CameraClient</span><br><span class="line">        // based on the requested HAL version.</span><br><span class="line">        if (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp;</span><br><span class="line">            halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">            // Only support higher HAL version device opened as HAL1.0 device.</span><br><span class="line">            client = new CameraClient(this, cameraClient,</span><br><span class="line">                    clientPackageName, cameraId,</span><br><span class="line">                    facing, callingPid, clientUid, getpid(), legacyMode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.</span><br><span class="line">            ALOGE(&quot;Invalid camera HAL version %x: HAL %x device can only be&quot;</span><br><span class="line">                    &quot; opened as HAL %x device&quot;, halVersion, deviceVersion,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_1_0);</span><br><span class="line">            return INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t status = connectFinishUnsafe(client, client-&gt;getRemote());</span><br><span class="line">    if (status != OK) &#123;</span><br><span class="line">        // this is probably not recoverable.. maybe the client can try again</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mClient[cameraId] = client;</span><br><span class="line">    LOG1(&quot;CameraService::connect X (id %d, this pid is %d)&quot;, cameraId,</span><br><span class="line">         getpid());</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，在CAMERA_DEVICE_API_VERSION_2_0之前使用CameraClient进行实例化，之后则采用Camera2Client进行实例化。以CameraClient为例，其initialize()函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">status_t CameraClient::initialize(camera_module_t *module) &#123;</span><br><span class="line">    int callingPid = getCallingPid();</span><br><span class="line">    status_t res;</span><br><span class="line"></span><br><span class="line">    LOG1(&quot;CameraClient::initialize E (pid %d, id %d)&quot;, callingPid, mCameraId);</span><br><span class="line"></span><br><span class="line">    // Verify ops permissions</span><br><span class="line">    res = startCameraOps();</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char camera_device_name[10];</span><br><span class="line">    snprintf(camera_device_name, sizeof(camera_device_name), &quot;%d&quot;, mCameraId);</span><br><span class="line"></span><br><span class="line">    mHardware = new CameraHardwareInterface(camera_device_name);</span><br><span class="line">    res = mHardware-&gt;initialize(&amp;module-&gt;common);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        ALOGE(&quot;%s: Camera %d: unable to initialize device: %s (%d)&quot;,</span><br><span class="line">                __FUNCTION__, mCameraId, strerror(-res), res);</span><br><span class="line">        mHardware.clear();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHardware-&gt;setCallbacks(notifyCallback,</span><br><span class="line">            dataCallback,</span><br><span class="line">            dataCallbackTimestamp,</span><br><span class="line">            (void *)(uintptr_t)mCameraId);</span><br><span class="line"></span><br><span class="line">    // Enable zoom, error, focus, and metadata messages by default</span><br><span class="line">    enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |</span><br><span class="line">                  CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE);</span><br><span class="line"></span><br><span class="line">    LOG1(&quot;CameraClient::initialize X (pid %d, id %d)&quot;, callingPid, mCameraId);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数中，主要注意以下流程：</p>
<ol>
<li>加粗的代码CameraHardwareInterface新建了了一个Camera硬件接口，当然，camera_device_name为摄像头设备名；</li>
<li>mHardware-&gt;initialize(&amp;module-&gt;common)调用底层硬件的初始化方法；</li>
<li>mHardware-&gt;setCallbacks将CamerService处的回调函数注册到HAL处。</li>
</ol>
<p>CameraHardwareInterface定义了Camera的硬件抽象特征，由此进入到HAL。</p>
<h2 id="四、HAL：CameraHardwareInterface"><a href="#四、HAL：CameraHardwareInterface" class="headerlink" title="四、HAL：CameraHardwareInterface"></a>四、HAL：CameraHardwareInterface</h2><p>CameraHardwareInterface的作用在于链接Camera Server和V4L2，通过实现CameraHardwareInterface可以屏蔽不同的driver对Camera Server的影响。CameraHardwareInterface同样虚拟继承自RefBase。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CameraHardwareInterface : public virtual RefBase &#123;</span><br><span class="line">public:</span><br><span class="line">    CameraHardwareInterface(const char *name)</span><br><span class="line">    &#123;</span><br><span class="line">        mDevice = 0;</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CameraHardwareInterface中包含了控制通道和数据通道，控制通道用于处理预览和视频获取的开始/停止、拍摄照片、自动对焦等功能，数据通道通过回调函数来获得预览、视频录制、自动对焦等数据。当需要支持新的硬件时就需要继承于CameraHardwareInterface ，来实现对应的功能。CameraHardwareInterface提供的public方法如下：<br><img src="/img/20160401-2.png" alt=""><br>在前一节中，initialize()函数调用了mHardware-&gt;initialize和mHardware-&gt;setCallbacks，下面来看下CameraHardwareInterface.h对其的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">status_t initialize(hw_module_t *module)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(&quot;Opening camera %s&quot;, mName.string());</span><br><span class="line">    camera_module_t *cameraModule = reinterpret_cast&lt;camera_module_t *&gt;(module);</span><br><span class="line">    camera_info info;</span><br><span class="line">    status_t res = cameraModule-&gt;get_camera_info(atoi(mName.string()), &amp;info);</span><br><span class="line">    if (res != OK) return res;</span><br><span class="line"></span><br><span class="line">    int rc = OK;</span><br><span class="line">    if (module-&gt;module_api_version &gt;= CAMERA_MODULE_API_VERSION_2_3 &amp;&amp;</span><br><span class="line">        info.device_version &gt; CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">        // Open higher version camera device as HAL1.0 device.</span><br><span class="line">        rc = cameraModule-&gt;open_legacy(module, mName.string(),</span><br><span class="line">                                           CAMERA_DEVICE_API_VERSION_1_0,</span><br><span class="line">                                           (hw_device_t **)&amp;mDevice);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rc = CameraService::filterOpenErrorCode(module-&gt;methods-&gt;open(</span><br><span class="line">            module, mName.string(), (hw_device_t **)&amp;mDevice));</span><br><span class="line">    &#125;</span><br><span class="line">    if (rc != OK) &#123;</span><br><span class="line">        ALOGE(&quot;Could not open camera %s: %d&quot;, mName.string(), rc);</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line">    initHalPreviewWindow();</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在initialize()方法中，通过cameraModule-&gt;open_legacy打开摄像头模组，initHalPreviewWindow()用于初始化Preview的相关流opspreview_stream_ops，初始化hal的预览窗口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void initHalPreviewWindow()</span><br><span class="line">&#123;</span><br><span class="line">    mHalPreviewWindow.nw.cancel_buffer = __cancel_buffer;</span><br><span class="line">    mHalPreviewWindow.nw.lock_buffer = __lock_buffer;</span><br><span class="line">    mHalPreviewWindow.nw.dequeue_buffer = __dequeue_buffer;</span><br><span class="line">    mHalPreviewWindow.nw.enqueue_buffer = __enqueue_buffer;</span><br><span class="line">    mHalPreviewWindow.nw.set_buffer_count = __set_buffer_count;</span><br><span class="line">    mHalPreviewWindow.nw.set_buffers_geometry = __set_buffers_geometry;</span><br><span class="line">    mHalPreviewWindow.nw.set_crop = __set_crop;</span><br><span class="line">    mHalPreviewWindow.nw.set_timestamp = __set_timestamp;</span><br><span class="line">    mHalPreviewWindow.nw.set_usage = __set_usage;</span><br><span class="line">    mHalPreviewWindow.nw.set_swap_interval = __set_swap_interval;</span><br><span class="line"></span><br><span class="line">    mHalPreviewWindow.nw.get_min_undequeued_buffer_count =</span><br><span class="line">            __get_min_undequeued_buffer_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** Set the notification and data callbacks */</span><br><span class="line">void setCallbacks(notify_callback notify_cb,</span><br><span class="line">                  data_callback data_cb,</span><br><span class="line">                  data_callback_timestamp data_cb_timestamp,</span><br><span class="line">                  void* user)</span><br><span class="line">&#123;</span><br><span class="line">    mNotifyCb = notify_cb;</span><br><span class="line">    mDataCb = data_cb;</span><br><span class="line">    mDataCbTimestamp = data_cb_timestamp;</span><br><span class="line">    mCbUser = user;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;%s(%s)&quot;, __FUNCTION__, mName.string());</span><br><span class="line"></span><br><span class="line">    if (mDevice-&gt;ops-&gt;set_callbacks) &#123;</span><br><span class="line">        mDevice-&gt;ops-&gt;set_callbacks(mDevice,</span><br><span class="line">                               __notify_cb,</span><br><span class="line">                               __data_cb,</span><br><span class="line">                               __data_cb_timestamp,</span><br><span class="line">                               __get_memory,</span><br><span class="line">                               this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set_callbacks中，<strong>notify_cb、</strong>data_cb、<strong>data_cb_timestamp和</strong>get_memory分别消息回调，数据回调，时间戳回调，以及内存相关操作的回调。</p>
<p>以上通过简略分析应用层调用Camera.open()之后在Framework、ART、Library以及HAL层的响应，来说明Android中Camera系统的整体架构，希望对读者能有一定的帮助，后续将在理解Camera整体架构的基础，探索更加高效的Preview方式，敬请期待！</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yhthu.com/2016/05/03/Android源码笔记——Camera系统架构/" data-id="cio9t5e7m000898rs1wc8m6ca" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android-Camera/">Android Camera</a></div><div class="post-nav"><a href="/2016/05/16/Android开发笔记——内存泄露与线程安全/" class="pre">Android开发笔记——内存泄露与线程安全</a><a href="/2016/05/03/Android线程管理（三）——Thread类的内部原理、休眠及唤醒/" class="next">Android线程管理（三）——Thread类的内部原理、休眠及唤醒</a></div><div data-thread-key="2016/05/03/Android源码笔记——Camera系统架构/" data-title="Android源码笔记——Camera系统架构" data-url="http://yhthu.com/2016/05/03/Android源码笔记——Camera系统架构/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/05/03/Android源码笔记——Camera系统架构/" data-title="Android源码笔记——Camera系统架构" data-url="http://yhthu.com/2016/05/03/Android源码笔记——Camera系统架构/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yhthu.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android内存管理/">Android内存管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发笔记/">Android开发笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android源码笔记/">Android源码笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android线程管理/">Android线程管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OOM分析/" style="font-size: 15px;">OOM分析</a> <a href="/tags/Volley架构/" style="font-size: 15px;">Volley架构</a> <a href="/tags/ListView/" style="font-size: 15px;">ListView</a> <a href="/tags/notifyDataSetChanged/" style="font-size: 15px;">notifyDataSetChanged</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/图片缓存/" style="font-size: 15px;">图片缓存</a> <a href="/tags/视频录制播放/" style="font-size: 15px;">视频录制播放</a> <a href="/tags/Android-Camera/" style="font-size: 15px;">Android Camera</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/Android内存管理/" style="font-size: 15px;">Android内存管理</a> <a href="/tags/进程内存/" style="font-size: 15px;">进程内存</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Android开发笔记——内存泄露与线程安全/">Android开发笔记——内存泄露与线程安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android源码笔记——Camera系统架构/">Android源码笔记——Camera系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android线程管理（三）——Thread类的内部原理、休眠及唤醒/">Android线程管理（三）——Thread类的内部原理、休眠及唤醒</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android线程管理（二）——ActivityThread/">Android线程管理（二）——ActivityThread</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android开发笔记——ListView模块、缓存及性能/">Android开发笔记——ListView模块、缓存及性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android开发笔记——视频录制播放常见问题/">Android开发笔记——视频录制播放常见问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计/">Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android线程管理（一）——线程通信/">Android线程管理（一）——线程通信</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Android开发笔记——图片缓存、手势及OOM分析/">Android开发笔记——图片缓存、手势及OOM分析</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://androidweekly.cn/" title="Android开发技术周报" target="_blank">Android开发技术周报</a><ul></ul><a href="http://p.codekk.com/" title="codeKK开源项目源码解析" target="_blank">codeKK开源项目源码解析</a><ul></ul><a href="http://www.trinea.cn/" title="Trinea技术博客" target="_blank">Trinea技术博客</a><ul></ul><a href="http://hukai.me/" title="胡凯技术博客" target="_blank">胡凯技术博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">道阻且长【yhthu.com】.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'yhthu'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>