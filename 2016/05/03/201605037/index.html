<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android开发笔记——视频录制播放常见问题 | 杨浩的个人博客【yhthu.com】</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android开发笔记——视频录制播放常见问题</h1><a id="logo" href="/.">杨浩的个人博客【yhthu.com】</a><p class="description">分享交流Android、CV、ML、NN等方面的技术和设计思想</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于yhthu</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android开发笔记——视频录制播放常见问题</h1><div class="post-meta">May 3, 2016<span> | </span><span class="category"><a href="/categories/Android开发笔记/">Android开发笔记</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/05/03/201605037/" href="/2016/05/03/201605037/#comments" class="ds-thread-count"></a><div class="post-content"><p>本文分享自己在视频录制播放过程中遇到的一些问题，主要包括：</p>
<ol>
<li>视频录制流程</li>
<li>视频预览及SurfaceHolder</li>
<li>视频清晰度及文件大小</li>
<li>视频文件旋转</li>
</ol>
<hr>
<h2 id="一、视频录制流程"><a href="#一、视频录制流程" class="headerlink" title="一、视频录制流程"></a>一、视频录制流程</h2><p>以微信为例，其录制触发为按下（住）录制按钮，结束录制的触发条件为松开录制按钮或录制时间结束，其流程大概可以用下图来描述。<br><img src="/img/20151230-1.png" alt=""></p>
<h3 id="1-1、开始录制"><a href="#1-1、开始录制" class="headerlink" title="1.1、开始录制"></a>1.1、开始录制</h3><p><img src="/img/20151230-2.png" alt=""><br>初始化过程主要包括View，Data以及Listener三部分。在初始化View时，添加摄像头预览，添加倒计时文本组件，设置初始状态UI组件的可见；初始化Data时，从Intent中获取初始数据；初始化Listener时，分别对录制触发按钮，保存/取消视频录制按钮以及视频预览界面添加监听。<br>当系统初始化成功后，等待用户按下录制按钮，因此在录制按钮的监听中，需要完成以下功能：录制，计时，更新界面组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(isRecording) &#123;</span><br><span class="line">    mMediaRecorder.stop();</span><br><span class="line">    releaseMediaRecorder();</span><br><span class="line">    mCamera.lock();</span><br><span class="line">    isRecording = false;</span><br><span class="line">&#125;</span><br><span class="line">if(startRecordVideo()) &#123;</span><br><span class="line">    startTimeVideoRecord();</span><br><span class="line">    isRecording = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断当前录制状态，如果正在录制，则先停止录制，释放MediaRecorder资源，锁定摄像头，置位录制状态；然后开始视频录制startRecordVideo，其boolean型返回值表征是否启动成功，启动成功后，开始视频录制计时，并且置位录制状态。startRecordVideo涉及MediaRecorder的配置，准备以及启动。<br><img src="/img/20151230-3.png" alt=""><br>翻译成代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean startRecordVideo() &#123;</span><br><span class="line">    configureMediaRecorder();</span><br><span class="line">    if(!prepareConfiguredMediaRecorder()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    mMediaRecorder.start();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2、结束录制"><a href="#1-2、结束录制" class="headerlink" title="1.2、结束录制"></a>1.2、结束录制</h3><p>根据上述流程图可知，结束录制的触发条件为松开录制按钮或计时时间到。在结束录制方法中，需要释放MediaRecorder，开始循环播放已录制视频，设置界面更新等。<br><img src="/img/20151230-4.png" alt=""><br> 翻译成代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void stopRecordVideo() &#123;</span><br><span class="line"></span><br><span class="line">    releaseMediaRecorder();</span><br><span class="line">    // 录制视频文件处理</span><br><span class="line">    if(currentRecordProgress &lt; MIN_RECORD_TIME) &#123;</span><br><span class="line">        Toast.makeText(VideoInputActivity.this, &quot;录制时间太短&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startVideoPlay();</span><br><span class="line">        isPlaying = true;</span><br><span class="line">        setUiDisplayAfterVideoRecordFinish();</span><br><span class="line">    &#125;</span><br><span class="line">    currentRecordProgress = 0;</span><br><span class="line">    updateProgressBar(currentRecordProgress);</span><br><span class="line">    releaseTimer();</span><br><span class="line">    // 状态设置</span><br><span class="line">    isRecording = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、视频预览及SurfaceHolder"><a href="#二、视频预览及SurfaceHolder" class="headerlink" title="二、视频预览及SurfaceHolder"></a>二、视频预览及SurfaceHolder</h2><p>视频预览采用SurfaceView，相比于普通的View，SurfaceView在一个新起的单独线程中绘制画面，该实现的优点是更新画面不会阻塞UI主线程，缺点是会带来事件同步的问题。当然，这涉及到UI事件的传递以及线程同步，这里不做详细说明，有兴趣的可以参考链接：<a href="http://wugengxin.cn/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf。" target="_blank" rel="external">http://wugengxin.cn/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf。</a><br>在实现中，通过继承SurfaceView组件来实现自定义预览控件。首先，SurfaceView的getHolder()方法会返回SurfaceHolder，需要为SurfaceHolder添加SurfaceHolder.Callback回调；其次，重写surfaceCreated、surfaceChanged和surfaceDestroyed实现。</p>
<h3 id="2-1、构造器"><a href="#2-1、构造器" class="headerlink" title="2.1、构造器"></a>2.1、构造器</h3><p>构造器包含了初始化域以及添加上述回调的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public CameraPreview(Context context, Camera camera) &#123;</span><br><span class="line">    super(context);</span><br><span class="line"></span><br><span class="line">    mCamera = camera;</span><br><span class="line">    mSupportedPreviewSizes = mCamera.getParameters().getSupportedPreviewSizes();</span><br><span class="line">    mHolder = getHolder();</span><br><span class="line">    mHolder.addCallback(this);</span><br><span class="line">    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要说明mSupportedPreviewSizes，由于摄像头支持的预览尺寸由Camera本身的参数决定，因此需要首先获取其所支持的预览尺寸。</p>
<h3 id="2-2、预览尺寸的设置"><a href="#2-2、预览尺寸的设置" class="headerlink" title="2.2、预览尺寸的设置"></a>2.2、预览尺寸的设置</h3><p>从Google官方的Camera示例程序中可以看出，选择预览尺寸的标准是（1）摄像头支持的预览尺寸的宽高比与SurfaceView的宽高比的绝对差值小于0.1；（2）在（1）获得的尺寸中，选取与SurfaceView的高的差值最小的。通过代码对这两个标准进行了实现，这里贴一下官方的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Camera.Size getOptimalPreviewSize(List&lt;Camera.Size&gt; sizes, int w, int h) &#123;</span><br><span class="line">    final double ASPECT_TOLERANCE = 0.1;</span><br><span class="line">    double targetRatio = (double) w / h;</span><br><span class="line">    if (sizes == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Camera.Size optimalSize = null;</span><br><span class="line">    double minDiff = Double.MAX_VALUE;</span><br><span class="line">    int targetHeight = h;</span><br><span class="line">    for (Camera.Size size : sizes) &#123;</span><br><span class="line">        double ratio = (double) size.width / size.height;</span><br><span class="line">        if (Math.abs(ratio - targetRatio) &gt; ASPECT_TOLERANCE)</span><br><span class="line">            continue;</span><br><span class="line">        if (Math.abs(size.height - targetHeight) &lt; minDiff) &#123;</span><br><span class="line">            optimalSize = size;</span><br><span class="line">            minDiff = Math.abs(size.height - targetHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (optimalSize == null) &#123;</span><br><span class="line">        minDiff = Double.MAX_VALUE;</span><br><span class="line">        for (Camera.Size size : sizes) &#123;</span><br><span class="line">            if (Math.abs(size.height - targetHeight) &lt; minDiff) &#123;</span><br><span class="line">                optimalSize = size;</span><br><span class="line">                minDiff = Math.abs(size.height - targetHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return optimalSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在加载预览画面时，需要考虑Camera支持的尺寸（getSupportedPreviewSizes）和加载预览画面的SurfaceView的尺寸（layout_width/layout_height），在预览阶段，两者之间的关系直接影响清晰度及图像拉伸。对于Camera的尺寸，由于设备的硬件差异，不同设备支持的尺寸存在差异，但在默认情况（orientation=landscape）下，其width&gt;height。以HTC609d为例，Camera支持的分辨率为1280<em>720（16：9）……640</em>480（4：3）……480<em>320（3：2）等十多种，而其屏幕的分辨率为960</em>540（16：9）。因此，很容易得到以下结论：（1）当Camera预览尺寸小于SurfaceView尺寸较多时，预览画面就不清晰；（2）Camera预览尺寸宽高比与SurfaceView宽高比相差较大时，预览画面就会拉伸。<br>上述代码在手机设置为横屏时并没有问题，在设置为竖屏时，为获得最优的预览尺寸，需要在调用此方法前比较SurfaceView的宽高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (mSupportedPreviewSizes != null) &#123;</span><br><span class="line">    mPreviewSize = getOptimalPreviewSize(mSupportedPreviewSizes, </span><br><span class="line">                        Math.max(width, height), Math.min(width, height));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获得与当前SurfaceView匹配的预览尺寸后，即可通过Camera.Parameters进行设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Camera.Parameters mParams = mCamera.getParameters();</span><br><span class="line">mParams.setPreviewSize(mPreviewSize.width, mPreviewSize.height);</span><br><span class="line">mCamera.setDisplayOrientation(90);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; focusModes = mParams.getSupportedFocusModes();</span><br><span class="line">if(focusModes.contains(&quot;continuous-video&quot;))&#123;</span><br><span class="line">    mParams.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);</span><br><span class="line">&#125;</span><br><span class="line">mCamera.setParameters(mParams);</span><br></pre></td></tr></table></figure></p>
<h2 id="三、视频清晰度及文件大小"><a href="#三、视频清晰度及文件大小" class="headerlink" title="三、视频清晰度及文件大小"></a>三、视频清晰度及文件大小</h2><p>在第一节中讲到startRecordVideo，包括配置MediaRecorder，准备MediaRecorder以及启动，其中配置MediaRecorder是视频录制的重点，需要了解每项配置参数的作用，根据业务场景灵活配置。这里参考Google官方的示例给出一个可行的配置方案，然后再对其进行解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void configureMediaRecorder() &#123;</span><br><span class="line">    // BEGIN_INCLUDE (configure_media_recorder)</span><br><span class="line">    mMediaRecorder = new MediaRecorder();</span><br><span class="line"></span><br><span class="line">    // Step 1: Unlock and set camera to MediaRecorder</span><br><span class="line">    mCamera.unlock();</span><br><span class="line">    mMediaRecorder.setCamera(mCamera);</span><br><span class="line">    mMediaRecorder.setOrientationHint(90);</span><br><span class="line"></span><br><span class="line">    // Step 2: Set sources</span><br><span class="line">    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.VOICE_RECOGNITION);</span><br><span class="line">    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line"></span><br><span class="line">    // Step 3: Set a Camera Parameters</span><br><span class="line">    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">    /* Fixed video Size: 640 * 480*/</span><br><span class="line">    mMediaRecorder.setVideoSize(640, 480);</span><br><span class="line">    /* Encoding bit rate: 1 * 1024 * 1024*/</span><br><span class="line">    mMediaRecorder.setVideoEncodingBitRate(1 * 1024 * 1024);</span><br><span class="line">    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line"></span><br><span class="line">    // Step 4: Set output file</span><br><span class="line">    mMediaRecorder.setMaxFileSize(maxFileSizeInBytes);</span><br><span class="line">    mMediaRecorder.setOutputFile(videoFilePath);</span><br><span class="line">    // END_INCLUDE (configure_media_recorder)</span><br><span class="line"></span><br><span class="line">    // Set MediaRecorder ErrorListener</span><br><span class="line">    mMediaRecorder.setOnErrorListener(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Step 1：</strong><br>setCamera参数能够使得在预览和录制中快速切换，避免Camera对象的重新加载。在某些Android手机自带的照相机程序中，切换预览与录制中的短暂卡顿，读者可自行体会。<br>mMediaRecorder.setOrientationHint(90)在录制方向为竖直（portrait）时使用，它能使视频文件的沿顺时针方向旋转90度，如果不设置此项，播放视频时，画面会发生90度的旋转。不过这里更重要的是，即使设置了此项，在某些播放器上，画面依然会有90度的旋转（比如将在手机上正常播放的视频导入到PC中进行播放，或者嵌入H5的video标签中），这可是为什么呢？注意setOrientationHint的说明：Note that some video players may choose to ignore the compostion matrix in a video during playback. 那么如何做到在所有播放器上都能以正常方向播放呢？稍等，后续专门对其进行说明。<br><strong>Step 2：</strong><br>setAudioSource(MediaRecorder.AudioSource.VOICE_RECOGNITION)，VOICE_RECOGNITION相比于MIC会根据语音识别的需要做一些调谐，当然，这需要在系统支持的情况下。<br>setVideoSource自然是VideoSource.CAMERA，只是在此两项设置必须在设置编码器之前设置，这无需说明。<br><strong>Step 3：</strong><br>setOutputFormat需要在Step 2之后，并且在prepare()之前。这里采用OutputFormat.MPEG_4格式。<br>setVideoSize需要权衡的因素较多，主要包括三方面：MediaRecorder支持的录制尺寸、视频文件的大小以及兼容不同Android机型。这里采用640 <em> 480（微信小视频的尺寸是320</em>240），文件大小在500-1000kb之间，并且市面上99%以上机型支持此录制尺寸。<br>setVideoEncodingBitRate与视频的清晰度有关，设置此参数需要权衡清晰度与文件大小的关系。太高，文件大不易传输；太低，文件清晰度低，识别率低。需要根据实际业务场景灵活调整。<br>setVideoEncoder采用H264编码，MPEG4、H263、H264等不同编码的差别比较可参考<a href="http://blog.csdn.net/wcl0715/article/details/676137，实际使用中，H264的压缩率较高，推荐使用。" target="_blank" rel="external">http://blog.csdn.net/wcl0715/article/details/676137，实际使用中，H264的压缩率较高，推荐使用。</a><br>setAudioEncoder采用AudioEncoder.AAC，该设置主要是考虑其通用性、兼容性。<br><strong>Step 4：</strong><br>setMaxFileSize指定录制文件的大小限制，当然还可以限制其最大录制时间。<br>setOutputFile指定输出视频的路径。<br>setOnErrorListener指定错误监听器。</p>
<p>在完成上述配置之后，即可准备MediaRecorder，并在返回成功后开始视频录制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private boolean prepareConfiguredMediaRecorder() &#123;</span><br><span class="line">    // Step 5: Prepare configured MediaRecorder</span><br><span class="line">    try &#123;</span><br><span class="line">        mMediaRecorder.prepare();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        releaseMediaRecorder();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、视频文件旋转"><a href="#四、视频文件旋转" class="headerlink" title="四、视频文件旋转"></a>四、视频文件旋转</h2><p>第三节中Step 1提到对视频文件的旋转，因为某些播放器会忽略录制视频时的配置参数，因此可尝试通过第三方库对视频文件进行旋转，例如：OpenCV，fastCV等，在Camera对象的Camera.PreviewCallback中截取每帧数据byte[] data，然后对其进行处理，然后输出。该方法需要考虑处理方法的高效性，在编程时一般采用NDK，在C++中完成关键的处理，这里贴出fastCV中该处理方法的逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void onPreviewFrame( byte[] data, Camera c ) &#123;</span><br><span class="line">    // Increment FPS counter for camera.</span><br><span class="line">    util.cameraFrameTick();</span><br><span class="line">    </span><br><span class="line">    // Perform processing on the camera preview data.</span><br><span class="line">    update( data, mDesiredWidth, mDesiredHeight );</span><br><span class="line">    </span><br><span class="line">    // Simple IIR filter on time.</span><br><span class="line">    mProcessTime = util.getFastCVProcessTime();</span><br><span class="line">    </span><br><span class="line">    if( c != null ) &#123;</span><br><span class="line">        // with buffer requires addbuffer each callback frame.</span><br><span class="line">        c.addCallbackBuffer( mPreviewBuffer );</span><br><span class="line">        c.setPreviewCallbackWithBuffer( this );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Mark dirty for render.</span><br><span class="line">    requestRender();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，update为native方法，其实现由jni中对应的文件完成，其中调用了libfastcv.a中相应的API。这里涉及NDK编程的基本方法步骤：（1）开发环境；（2）编写Java代码、C/C++代码；（3）编译C/C++文件生成.so库；（4）重新编译工程，生成apk。由于本章不重点讲述NDK，这里不再展开。<br>除上述方法以外，笔者采用了另外一种思路进行了探索，上述方法处理的数据为每帧图像数据，可以理解为在线处理，而如果在录制完成之后再处理，可以理解为离线处理。这里采用了第三方库mp4parser，mp4parser是一款支持在Android中进行视频分割的库，这里通过其进行视频旋转。至于具体效果如何，读者有兴趣可自行尝试，这里留个悬念。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean rotateVideoFileWithClockwiseDegree(String sourceFilePath, int degree) &#123;</span><br><span class="line">    if(!isFileAndDegreeValid(sourceFilePath, degree)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    rotateVideoFile(sourceFilePath, degree);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对输入参数进行合法性检测之后，根据检测结果判断是否进行旋转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private boolean isFileAndDegreeValid(String sourceFilePath, int degree) &#123;</span><br><span class="line">    if(sourceFilePath == null || (!sourceFilePath.endsWith(&quot;.mp4&quot;)) </span><br><span class="line">                              || (!new File(sourceFilePath).exists())) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (degree == 0 || (degree % 90 != 0)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void rotateVideoFile(String sourceFilePath, int degree) &#123;</span><br><span class="line">    List&lt;TrackBox&gt; trackBoxes = getTrackBoxesOfVideoFileByPath(sourceFilePath);</span><br><span class="line">    Movie rotatedMovie = getRotatedMovieOfTrackBox(trackBoxes);</span><br><span class="line">    writeMovieToModifiedFile(rotatedMovie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过mp4parser旋转视频主要分为三步：（1）获取视频文件对应的TrackBoxes；（2）根据TrackBoxes获取旋转后的Movie对象；（3）将Movie对象写入文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;TrackBox&gt; getTrackBoxesOfVideoFileByPath(String sourceFilePath) &#123;</span><br><span class="line">    IsoFile isoFile = null;</span><br><span class="line">    List&lt;TrackBox&gt; trackBoxes = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        isoFile = new IsoFile(sourceFilePath);</span><br><span class="line">        trackBoxes = isoFile.getMovieBox().getBoxes(TrackBox.class);</span><br><span class="line">        isoFile.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return trackBoxes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Movie getRotatedMovieOfTrackBox(List&lt;TrackBox&gt; trackBoxes) &#123;</span><br><span class="line">    Movie rotatedMovie = new Movie();</span><br><span class="line">    // 旋转</span><br><span class="line">    for (TrackBox trackBox : trackBoxes) &#123;</span><br><span class="line">        trackBox.getTrackHeaderBox().setMatrix(Matrix.ROTATE_90);</span><br><span class="line">        rotatedMovie.addTrack(new Mp4TrackImpl(trackBox));</span><br><span class="line">    &#125;</span><br><span class="line">    return rotatedMovie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void writeMovieToModifiedFile(Movie movie) &#123;</span><br><span class="line">    Container container = new DefaultMp4Builder().build(movie);</span><br><span class="line">    File modifiedVideoFile = new File(videoFilePath.replace(&quot;.mp4&quot;, &quot;_MOD.mp4&quot;));</span><br><span class="line">    FileOutputStream fos;</span><br><span class="line">    try &#123;</span><br><span class="line">        fos = new FileOutputStream(modifiedVideoFile);</span><br><span class="line">        WritableByteChannel bb = Channels.newChannel(fos);</span><br><span class="line">        container.writeContainer(bb);</span><br><span class="line">        // 关闭文件流</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文对Android视频录制中常见的问题进行了说明，转载请注明出处（虽然也没什么转载）。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yhthu.com/2016/05/03/201605037/" data-id="citf2prlp000cvsrs2ifkxtq7" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/视频录制播放/">视频录制播放</a></div><div class="post-nav"><a href="/2016/05/03/201605038/" class="pre">Android开发笔记——ListView模块、缓存及性能</a><a href="/2016/05/03/201605035/" class="next">Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</a></div><div data-thread-key="2016/05/03/201605037/" data-title="Android开发笔记——视频录制播放常见问题" data-url="http://yhthu.com/2016/05/03/201605037/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/05/03/201605037/" data-title="Android开发笔记——视频录制播放常见问题" data-url="http://yhthu.com/2016/05/03/201605037/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yhthu.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android内存管理/">Android内存管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发笔记/">Android开发笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android源码笔记/">Android源码笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android线程管理/">Android线程管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/notifyDataSetChanged/" style="font-size: 15px;">notifyDataSetChanged</a> <a href="/tags/Android-Camera/" style="font-size: 15px;">Android Camera</a> <a href="/tags/Volley架构/" style="font-size: 15px;">Volley架构</a> <a href="/tags/图片缓存/" style="font-size: 15px;">图片缓存</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/OOM分析/" style="font-size: 15px;">OOM分析</a> <a href="/tags/视频录制播放/" style="font-size: 15px;">视频录制播放</a> <a href="/tags/ListView/" style="font-size: 15px;">ListView</a> <a href="/tags/Android线程/" style="font-size: 15px;">Android线程</a> <a href="/tags/Android内存管理/" style="font-size: 15px;">Android内存管理</a> <a href="/tags/进程内存/" style="font-size: 15px;">进程内存</a> <a href="/tags/Theory-Algorithms-Implementation/" style="font-size: 15px;">Theory, Algorithms, Implementation</a> <a href="/tags/Perceiving-and-modeling-environment/" style="font-size: 15px;">Perceiving and modeling environment</a> <a href="/tags/Android架构/" style="font-size: 15px;">Android架构</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/MVC/" style="font-size: 15px;">MVC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/201609221/">Android App的架构设计：从VM、MVC、MVP到MVVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/201605161/">Android开发笔记——内存泄露与线程安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/201605201/">读书笔记-Autonomous Intelligent Vehicles（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605031/">Android源码笔记——Camera系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605034/">Android线程管理（三）——Thread类的内部原理、休眠及唤醒</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605033/">Android线程管理（二）——ActivityThread</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605038/">Android开发笔记——ListView模块、缓存及性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605037/">Android开发笔记——视频录制播放常见问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605035/">Android开发笔记——以Volley图片加载、缓存、请求及展示为例理解Volley架构设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/201605032/">Android线程管理（一）——线程通信</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://androidweekly.cn/" title="Android开发技术周报" target="_blank">Android开发技术周报</a><ul></ul><a href="http://p.codekk.com/" title="codeKK开源项目源码解析" target="_blank">codeKK开源项目源码解析</a><ul></ul><a href="http://www.trinea.cn/" title="Trinea技术博客" target="_blank">Trinea技术博客</a><ul></ul><a href="http://hukai.me/" title="胡凯技术博客" target="_blank">胡凯技术博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">杨浩的个人博客【yhthu.com】.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'yhthu'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>